trick and importance:
#1 for left,right pointer, remember to left++ and right--
#2 speel check, focus on ; )  make sure no : in the end, checking missing return statement
#3 make sure check above #2 when writing everyline codes
#4 to calculate distance with sum, add map.put(0, -1) to make it easier
#5 the spell of length
#6 remember to consider the carray when adding to listnodes
#7 add ; to the comparator
#8 remember to initialize variable 
#9  when remove last element from list, used
list.remove(list.size()-1)
#10 quickselect: average time O(N) - n+n/2+n/4.., worst(O(N2)) if reversed
mistakes and importance:
#11  type has to be in Comparator<type> comparator = new Comparator<type>()

#186 Reverse Words in a String II
forgot to shift left++ and right--
remember to handle the edge case(i.e in the end)


#325Maximum Size Subarray Sum Equals k
added map.put(0, -1) to make it easy to calculate distance(i - pos)
try to finish everything in one loop

#Compare Version Numbers
make sure fill the missing length with 0

#Longest Palindromic Substring
Forgot to right else case
if(s.charAt(left) == s.charAt(right)){}else{return;}

#238. Product of Array Except Self
  using    int leftSides = 1, int rightSides = 1;

#287. Find the Duplicate Number
remember to use count to check with the mid value; if count > mid, then move high to mid

# Add Two Numbers
forgot to add the carry
need to add () around the conditional operator ?:

#160. Intersection of Two Linked Lists
forgot to move the point when calculate the list len
forgot to handle the edge case

# Merge k Sorted Lists
for using priorityQueue:
  forgot the check the null node
for Divide and conquer using two way merge:
 code could more precise. using while(right >0)

#98. Validate Binary Search Tree
3 solutions, top to bottom valid, in order search with recursion and iteration
for the iteration solution, could use   curr = curr.right;
instead of below,
    if(curr.right != null){
        curr = curr.right;
    }else{
        curr = null;
    }
#101. Symmetric Tree
used recursion or iteration with two queues 

# 270. Closest Binary Search Tree Value
the diff should be assigned Double.MAX_VALUE  
the diff should be > instead of <
  if(diff > Math.abs(target - curr.val)){

#129. Sum Root to Leaf Numbers
check root by left and right node, check null of them
if(root.left == null && root.right == null){  

#654. Maximum Binary Tree
Forgot the create node will real number(shouldn't be the index it self)
 int nodeIndex = findIndexOfMax(nums, start, end);
 TreeNode node = new TreeNode(nodeIndex);

#653. Two Sum IV - Input is a BST
forgot to check k==root.val case
forgot to check (curr.val != k - curr.val)
forgot to check missing return statement
forgot to check root has no leafs case

#572. Subtree of Another Tree
added wrong nodes into the queue, should be n1, n2 instead of curr q1.add(curr.left);
using recursion seems easier

#102. Binary Tree Level Order Traversal
 if (levelCount == 0) should be check after if(levelCount> 0) check, instead of if/else case

# 314. Binary Tree Vertical Order Traversal
 make sure the min and max data assign is opposite
    private int min = Integer.MAX_VALUE;
    private int max = Integer.MIN_VALUE;

#Inorder Successor in BST
Didn't notice this is BST

#200. Number of Islands
didn't notice the grid are chars
char[][] grid
if(grid[row][col] == 1) is not going to work
with union find: the union function should be
parent[pu] = parent[pv];
the grid pos: should be cols*row+ col


#261. Graph Valid Tree
with dfs, 1st, create all the list within the map in advance
2nd: check the status in the end of dfs to make sure all the nodes are touched
with unionfind solution: union method, should be parents[pv] = pu instead of parents[v] = u;
need to check n -1 == edges.length

#210. Course Schedule II
should handle dependency is empty case
  if( prerequisites ==null || prerequisites.length == 0){
      for(int i= 0; i< numCourses;i++){
          res[i] = i;
      }
      return res;
  }

 return empty array should be:
if(!dfs(list, i, status, resList)){
                return new int[0];
} 

207. Course Schedule
use 3 status
int status[] = new int[numCourses];
used list<list<Integer>> to store the edge information

#269. Alien Dictionary
use topological and dfs
similar with course schedule

#39. Combination Sum
mistakes made.
#a. in the backtrack method, the position should start the same instead of i+1;
#b. when remove last element from list, used
list.remove(list.size()) which threw the null point exception
backtrack template:
step 1: in main method: invoked
backtrack(res, new ArrayList<Integer>(), candidates, 0, target);

step2: in implementation method, go through all the elements and add, backtrack , remove last elements
 for(int i = pos; i < candidates.length; i++){
    currList.add(candidates[i]);
    backtrack(res, currList, candidates, i, target - candidates[i]);
    currList.remove(currList.size()-1);
}

17. Letter Combinations of a Phone Number
mistake: should use char as the key of map
 map.put('2', Arrays.asList('a','b','c'));

 backtrack template:
step 1: in main method: invoked
backtrack(res, new StringBuilder(), digits, 0);

step2: in implementation method, go through  the elements and add, backtrack , remove last elements

loop the possible candidate
int index = digits.charAt(pos) - '0';
        
for(char c: keys[index].toCharArray()){
    sb.append(c);
    backtrack(res,sb,digits, pos+1);
    sb.deleteCharAt(sb.length()-1);
}

#215. Kth Largest Element in an Array
need quickselect to invoke the partition
in the partition, should always check left<=right on each steps!

while(left <= right){
    while(left <=right && nums[left]<= nums[pivot]) left++;
    while(left<=right && nums[right] > nums[pivot]) right--;
    if(left <= right){
        swap(nums,left, right);
    }
}


#127. Word Ladder
 use Set<String> wordSet = new HashSet<>(wordList);
 use bfs + 26 letters

#126 Word Ladder II
tricky:the used word can not directly removed from the dictionary. The used word is only removed when steps change.
Used to visisted and unvisited set to check and make sure the same word could be added mulitple times in the same level

used bfs to get the graph(reversed way) and dfs to get the list. check word==startword. added word first after the operation, remove it from the list;

used 26 letters to find the right candidates

252. Meeting Rooms
sort withstart, get max end and compare with the new start in the loop



