

001. TwoSum.txt

/*Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

company: amazon
*/

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        
        for(int index=0; index < nums.length; index++){
            int num1 = nums[index];
            
            int num0 = target - num1;
            
            if(map.containsKey(num0)){
                int indexOfNum0 = map.get(num0); 
                return new int[]{indexOfNum0, index};
            }else{
                map.put(nums[index], index);    
            }
        }
        
        return null;
        
    }
}
 


002. Add Two Numbers.txt

Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.

solution: carry and dummy listnode
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;
        int carry = 0;
        
        while(l1 != null || l2 != null){
            int sum = (l1==null?0:l1.val) + (l2==null?0:l2.val) + carry;
            carry = sum/10;
            head.next = new ListNode(sum%10);
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
            head = head.next;
        }
        
        if(carry > 0){
            head.next = new ListNode(carry);
        }
        
        return dummy.next;
    }
}


003. Longest Substring Without Repeating Characters.txt

Given a string, find the length of the longest substring without repeating characters.
Examples:
Given "abcabcbb", the answer is "abc", which the length is 3.
Given "bbbbb", the answer is "b", with the length of 1.
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null){
            return 0;
        }
        
        if(s.length() <2){
           return s.length(); 
        }
        
        Set<Character> set = new HashSet<>();
        int res = Integer.MIN_VALUE;
        for(int left = 0, right = 0 ; left <s.length() && right < s.length(); right++){
            if(!set.contains(s.charAt(right))){
                set.add(s.charAt(right));
                res = Math.max(res, right-left+1);
            }else{
                while(left<right && set.contains(s.charAt(right))){
                    set.remove(s.charAt(left++));
                }
            }
            set.add(s.charAt(right));
            
        }
        
        return res;
        
    }
}


004. Median of Two Sorted Arrays.txt

There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5

public class Solution {
    /*
     * @param A: An integer array
     * @param B: An integer array
     * @return: a double whose format is *.5 or *.0
     */
    public double findMedianSortedArrays(int[] A, int[] B) {
        // write your code here
        int lenA = A.length;
        int lenB = B.length;
        
        int median1 = (lenA + lenB + 1)/2;
        int median2 = (lenA + lenB + 2)/2;
        
        return (findKth(A, B, 0,0,median1) + findKth(A,B, 0,0, median2))/2.0;
    
    }
    
    public int findKth(int[] A, int[] B, int startA, int startB, int k){
        if(startA ==A.length){
            return B[startB+k-1];
        }
        
        if(startB == B.length ){
            return A[startA+ k-1];
        }
        
        if(k == 1){
            return Math.min(A[startA], B[startB]);
        }
        /**
        那么如何判断两个有序数组A,B中第k大的数呢？
        我们需要判断A[k/2-1]和B[k/2-1]的大小。
        如果A[k/2-1]==B[k/2-1]，那么这个数就是两个数组中第k大的数。
        如果A[k/2-1]<B[k/2-1], 那么说明A[0]到A[k/2-1]都不可能是第k大的数，所以需要舍弃这一半，继续从A[k/2]到A[A.length-1]继续找。当然，因为这里舍弃了A[0]到A[k/2-1]这k/2个数，那么第k大也就变成了，第k-k/2个大的数了。
        如果 A[k/2-1]>B[k/2-1]，就做之前对称的操作就好。
         这样整个问题就迎刃而解了。

        当然，边界条件页不能少，需要判断是否有一个数组长度为0，以及k==1时候的情况。

        因为除法是向下取整，并且页为了方便起见，对每个数组的分半操作采取：

        int partA = Math.min(k/2,m);
        int partB = k - partA; 

         为了能保证上面的分半操作正确，需要保证A数组的长度小于B数组的长度。
        **/
        
        int aMid = Integer.MAX_VALUE;
        int bMid = Integer.MAX_VALUE;
        
        if(startA + k/2 -1 < A.length){
            aMid = A[startA + k/2-1];
        }
        
        if(startB + k/2 -1 < B.length){
            bMid = B[startB + k/2 -1];
        }
        
        if(aMid < bMid){
            return findKth(A, B, startA+k/2, startB, k-k/2);/**
        那么如何判断两个有序数组A,B中第k大的数呢？
        我们需要判断A[k/2-1]和B[k/2-1]的大小。
        如果A[k/2-1]==B[k/2-1]，那么这个数就是两个数组中第k大的数。
        如果A[k/2-1]<B[k/2-1], 那么说明A[0]到A[k/2-1]都不可能是第k大的数，所以需要舍弃这一半，继续从A[k/2]到A[A.length-1]继续找。当然，因为这里舍弃了A[0]到A[k/2-1]这k/2个数，那么第k大也就变成了，第k-k/2个大的数了。
        如果 A[k/2-1]>B[k/2-1]，就做之前对称的操作就好。
         这样整个问题就迎刃而解了。

        当然，边界条件页不能少，需要判断是否有一个数组长度为0，以及k==1时候的情况。

        因为除法是向下取整，并且页为了方便起见，对每个数组的分半操作采取：

        int partA = Math.min(k/2,m);
        int partB = k - partA; 

         为了能保证上面的分半操作正确，需要保证A数组的长度小于B数组的长度。
        **/
        }else{
            return findKth(A,B,startA, startB+k/2, k-k/2);
        }
        
        
    }
}


005. Longest Palindromic Substring.txt

Longest Palindromic Substring
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"

class Solution {
    int l = 0, h = 0;
    public String longestPalindrome(String s) {
        if(s == null || s.length() == 1){
            return s;
        }
        
        int len = s.length();
        
        for(int i = 0; i< len; i++){
            scanFromCenter(s,i,i);
            scanFromCenter(s,i,i+1);
        }
        
        return s.substring(l, h+1);
    }
    
    private void scanFromCenter(String s, int left, int right){
        while(left >= 0 && right <s.length()){
            if(s.charAt(left) == s.charAt(right)){
                if((right - left +1) > (h-l+1)){
                    l = left;
                    h = right;
                }
                left--;
                right++;
            }else{
                return;
            }
        }
        
    }
}

010. Regular Expression Matching.txt

Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false

solution 1(recursion):
class Solution {
    public boolean isMatch(String s, String p) {
        if(p.isEmpty()){
            return s.isEmpty();
        }

        
        boolean firstMatch = !s.isEmpty() && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0));
        
        if(p.length()>=2 && p.charAt(1) == '*'){
            return isMatch(s, p.substring(2)) ||
                firstMatch && isMatch(s.substring(1), p);
        }else{
            return firstMatch && isMatch(s.substring(1), p.substring(1));
        }
        
    }
}


012. Integer to Roman.txt

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: "III"
Example 2:

Input: 4
Output: "IV"
Example 3:

Input: 9
Output: "IX"
Example 4:

Input: 58
Output: "LVIII"
Explanation: C = 100, L = 50, XXX = 30 and III = 3.
Example 5:

Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

class Solution {
    public String intToRoman(int num) {
        if(num <=0) return "";
                
        int val[] = {1,4, 5,9,10,40, 50,90, 100,400,500,900,1000};
        String chars[] = {"I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M"};
        
        int count = 0;
        int index = val.length -1;
        StringBuilder sb = new StringBuilder();
        
        while(num > 0 && index >= 0){
            count = num/val[index];
            
            for(int i = 0; i < count; i++){
                sb.append(chars[index]);
                num = num - val[index];
            }
            index--;
            
        }
        
        return sb.toString();
    }
    
}


013. Roman to Integer.txt

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: "III"
Output: 3
Example 2:

Input: "IV"
Output: 4
Example 3:

Input: "IX"
Output: 9
Example 4:

Input: "LVIII"
Output: 58
Explanation: C = 100, L = 50, XXX = 30 and III = 3.
Example 5:

Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

solution 1: version 1
/**
 Just check if the current character has a smaller value than the next character. If so, use the subtractive rule, otherwise just adds its value and continue.
*/
class Solution {
    public int romanToInt(String s) {
        if(s == null || s.length() == 0) return 0;
        
        Map<Character,Integer> map = new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        
        int res = 0;
        for(int i = 0; i < s.length();){
            char curr = s.charAt(i);
            if(i == s.length()-1){
                res += map.get(curr);
                i++;
            }else{
                char next = s.charAt(i+1);
                if(map.get(curr) < map.get(next)){
                    res += map.get(next) - map.get(curr);
                    i = i+2;
                }else{
                    res += map.get(curr);
                    i++;
                }
                
            }
        }
        
        return res;
    }
}


solution 1: version 2

class Solution {
    public int romanToInt(String s) {
        if(s == null || s.isEmpty()){
            return 0;
        }
        
        Map<Character,Integer> map = new HashMap<>();
        map.put('I',1);
        map.put('V', 5);
        map.put('X',10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D',500);
        map.put('M',1000);
        
        int sum = 0, index = 0;
        
        while(index < s.length()){
            int currVal = map.get(s.charAt(index));
            
            if(index < s.length() -1 && currVal < map.get(s.charAt(index+1))){
                sum += map.get(s.charAt(index+1)) - currVal;
                index = index +2;
            }else{
                sum += currVal;
                index++;
            }
            
            
        }
        return sum;
        
    }
}


015. 3Sum.txt

Pick One

Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Map<Integer,Integer> map = new HashMap<>();
        if(nums == null || nums.length == 0){
            return res;
        }
        
        Arrays.sort(nums);
        
        for(int i = 0; i < nums.length-2;i++){
            if(i == 0 || nums[i] != nums[i-1]){
                findPair(res, nums, i, i+1, nums.length-1, -nums[i]);    
            }   
        }
        
        return res;
        
    }
    
    private void findPair(List<List<Integer>> res, int[] nums,int curr, int start, int end, int target){
        int l = start;
        int r = end;
        while(l< r){
            if(nums[l] + nums[r] == target){
                res.add(Arrays.asList(nums[curr],nums[l],nums[r]));
                while(l<r && nums[l] == nums[l+1]) l++;
                while(l<r && nums[r] == nums[r-1]) r--;
                l++;
                r--;
            }else if(nums[l]+nums[r] < target){
                l++;
            }else{
                r--;
            }
        
        }
        
    }
}


017. Letter Combinations of a Phone Number.txt

17. Letter Combinations of a Phone Number
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.



Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.

solution 1: backtrack + map
class Solution {
    Map<Character,List<Character>> map = new HashMap<>();
    public List<String> letterCombinations(String digits) {
        init(map);
        List<String> res = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return res;
        }
        
        backtrack(res, new StringBuilder(), digits, 0);
        return res;
    }
    
    private void backtrack(List<String> res, StringBuilder sb, String digits, int pos){
        if(pos > digits.length()){
            return;
        }
        
        if(pos == digits.length()){
            res.add(sb.toString());
            return;
        }
        
        char curr = digits.charAt(pos);

        for(char c: map.get(curr)){
            sb.append(c);
            backtrack(res,sb,digits, pos+1);
            sb.deleteCharAt(sb.length()-1);
        }
        
    }
    
    private void init(Map<Character,List<Character>> map){
        map.put('2', Arrays.asList('a','b','c'));
        map.put('3',Arrays.asList('d','e','f'));
        map.put('4',Arrays.asList('g','h','i'));
        map.put('5',Arrays.asList('j','k','l'));
        map.put('6',Arrays.asList('m','n','o'));
        map.put('7',Arrays.asList('p','q','r','s'));
        map.put('8',Arrays.asList('t','u','v'));
        map.put('9',Arrays.asList('w','x','y','z'));
    }
}

solution 2: backtrack + string array
class Solution {
    String keys[] = {"0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return res;
        }
        
        backtrack(res, new StringBuilder(), digits, 0);
        return res;
    }
    
    private void backtrack(List<String> res, StringBuilder sb, String digits, int pos){
        if(pos > digits.length()){
            return;
        }
        
        if(pos == digits.length()){
            res.add(sb.toString());
            return;
        }
        
        int index = digits.charAt(pos) - '0';
        
        for(char c: keys[index].toCharArray()){
            sb.append(c);
            backtrack(res,sb,digits, pos+1);
            sb.deleteCharAt(sb.length()-1);
        }
        
    }
    
   
}

020. Valid Parentheses.txt

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true

class Solution {
    public boolean isValid(String s) {
        if(s == null || s.length()== 0) return true;
        Stack<Character> stack = new Stack<>();
        Map<Character,Character> map = new HashMap<>();
        map.put(')','(');
        map.put(']','[');
        map.put('}','{');
        
        char chars[] = s.toCharArray();
        
        for(char c: chars){
            if(!map.containsKey(c)){
                stack.push(c);
            }else{
                if(stack.isEmpty()){
                    return false;
                }else{
                    if(stack.pop() != map.get(c)){
                        return false;
                    }
                }
            }
            
        }
        
        return stack.isEmpty();
        
        
    }
}


021. Merge Two Sorted Lists.txt

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);//will return dummyHead.next in the end;
        ListNode curr = dummyHead;
        
        while(l1 !=null && l2 !=null){
            int val1 = l1.val;
            int val2 = l2.val;
            
            if(val1 < val2){
                curr.next = new ListNode(val1);
                l1 = l1.next;
            }else{
                curr.next = new ListNode(val2);
                l2 = l2.next;
            }
            
            curr = curr.next;
        }
        
        if (l1 != null){
            curr.next = l1;
        }
        
         if (l2 != null){
            curr.next = l2;
        }
        
        
        return dummyHead.next;
        
    }
}


022. Generate Parentheses.txt

Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example
Given n = 3, a solution set is:

"((()))", "(()())", "(())()", "()(())", "()()()"


public class Solution {
    /**
     * @param n: n pairs
     * @return: All combinations of well-formed parentheses
     */
    public List<String> generateParenthesis(int n) {
        // write your code here
        List<String> res = new ArrayList<>();
        if(n == 0){
            return res;
        }
        
        generateParenthesisRec(res, n , new StringBuilder() , 0, 0);
        return res;
        
    }
    
    private void generateParenthesisRec(List<String> res, int n, StringBuilder sb, int leftCount, int rightCount){
        
        if(leftCount >= n && rightCount >=n){
            res.add(sb.toString());
        }
        
        if(leftCount < n){
            sb.append('(');
            generateParenthesisRec(res, n, sb, leftCount+1, rightCount);
            sb.deleteCharAt(sb.length()-1);
        }
        
        if(rightCount < leftCount){
            sb.append(')');
            generateParenthesisRec(res, n, sb, leftCount, rightCount+1);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}


class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if(n == 0){
            return res;
        }
        
        backtrack(res, "", 0, 0, n);
        
        return res;
        
    }
    
    public void backtrack(List<String> res, String str, int open, int close, int n){
        
        if(str.length() == n*2){
            res.add(str);
            return;
        }
        
        if(open < n){
            backtrack(res, str+"(", open+1, close,n);
        }

        if(close < open){
            backtrack(res, str +")", open, close+1,n);
        }
        
    }
}


023. Merge k Sorted Lists.txt

Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

solution 1: priorityqueue
time complexity: O(nklgk)
space complexity: O(k)
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null || lists.length == 0){
            return null;
        }
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;
        Comparator<ListNode> comparator = new Comparator<ListNode>(){
            @Override
            public int compare(ListNode l1, ListNode l2){
                return l1.val - l2.val;
            }
        };
        PriorityQueue<ListNode> pq = new PriorityQueue<>(comparator);
        
        for(ListNode node: lists){
            if(node !=null){
                pq.add(node);
            }
        }
        
        while(!pq.isEmpty()){
            ListNode curr = pq.remove();
            head.next = new ListNode(curr.val);
            head = head.next;
            if(curr.next != null){
                pq.add(curr.next);
            }
        }
        
        
        return dummy.next;
    }
}

#solution 2: merge list
time O(nklgk)
space O(1)
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null || lists.length == 0){
            return null;
        }
        
        int left = 0;
        int right = lists.length -1;
        while(right > 0){
            left = 0;
            while(left < right){
                lists[left] = mergeList(lists[left], lists[right]);
                left++;
                right--;
            }
            
        }
        
        return lists[0];
        
    }
    
    private ListNode mergeList(ListNode l1, ListNode l2){
        ListNode dummyNode = new ListNode(-1);
        ListNode head= dummyNode;
        
        while(l1 != null && l2 != null){
            if(l1.val > l2.val){
                head.next = new ListNode(l2.val);
                l2 = l2.next;
            }else{
                head.next = new ListNode(l1.val);
                l1 = l1.next;
            }
            head = head.next;
        }
        
        if(l1 != null){
            head.next = l1;
        }
        
        if(l2 != null){
            head.next = l2;
        }
        
        return dummyNode.next;
        
    }
}


024. Swap Nodes in Pairs.txt

Given a linked list, swap every two adjacent nodes and return its head.

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.
Note:

Your algorithm should use only constant extra space.
You may not modify the values in the list's nodes, only nodes itself may be changed.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;
        
        ListNode headNext = head.next;
        head.next = swapPairs(head.next.next);
        headNext.next = head;
        
        return headNext;
    }
}


026. Remove Duplicates from Sorted Array.txt

Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums == null || nums.length== 0) return 0;
        int len = nums.length;
        if(len == 1) return 1;
        
        int left = 0,right=1;
        
        while(right < len){
            if(nums[left] != nums[right]){
                left++;
                nums[left] = nums[right];
              
            }
            right++;
            
        }
        
        return left+1;
        
    }
}

class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums == null || nums.length== 0) return 0;
        int len = nums.length;
        if(len == 1) return 1;
        
        int left = 0,right=1, res = 1;
        
        while(right < len){
            if(nums[left] != nums[right]){
                left++;
                res++;
                nums[left] = nums[right];
                right++;
            }else{
                right++;
            }
            
            
        }
        
        return res;
        
    }
}


028. Implement strStr().txt

Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().

class Solution {
    public int strStr(String haystack, String needle) {
        if(haystack == null || haystack.length() == 0){
              if(needle == null || needle.length() == 0){
                  return 0;
              }else{
                  return -1;
              }
        }
       /*
         if(needle == null || needle.length() == 0){
             return 0;
        }*/
        
        int hLen = haystack.length();
        int nLen = needle.length();
        if(hLen < nLen) return -1;
        boolean successful = true;
        
        for(int hIndex = 0; hIndex < (hLen-nLen+1); hIndex++){
            successful = true;
            for(int nIndex = 0; nIndex< nLen; nIndex++){
                if(haystack.charAt(nIndex + hIndex) != needle.charAt(nIndex)){
                    successful = false;
                    break;
                }
            }
            if(successful == true){
                return hIndex;
            }
            
        }
        return -1;
    }
}


public class Solution {
    /*
     * @param source: source string to be scanned.
     * @param target: target string containing the sequence of characters to match
     * @return: a index to the first occurrence of target in source, or -1  if target is not part of source.
     */
    public int strStr(String source, String target) {
        // write your code here

        if(source != null && target != null){
            if(source.isEmpty() && target.isEmpty()){
                return 0;
            }
            if(target.length() > source.length()){
                return -1;
            }
            
            for(int i = 0; i < source.length();i++){
                
               if(findTarget(source, i, target)) {
                   return i;
               }
               
            }
        }
        
        return -1;
    }
    
    public boolean findTarget(String source, int start, String target){
        int len = source.length();
        
        if(len - start < target.length()){
            return false;
        }
        
        for(int i = start; i < start+target.length(); i++){
            if(source.charAt(i) != target.charAt(i-start)){
                return false;
            }
            
        }
        
        return true;
    }
}


033. Search in Rotated Sorted Array.txt

33. Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

solution 1: version 1
class Solution {
    public int search(int[] nums, int target) {
        if(nums == null || nums.length == 0) return -1;
        int l = 0, r = nums.length-1;
        
        while(l + 1 < r){
            int m = l + (r -l)/2;
            
            if(nums[m] >= nums[l]){
                if(target >= nums[l] && target <= nums[m]){
                    r = m;
                }else{
                    l = m;
                }
            }else{
                if(target >= nums[m] && target <= nums[r]){
                    l = m;
                }else{
                    r = m;
                }
            }
        }
        
        
        return target == nums[l]? l: target == nums[r]? r: -1;
               
    }
}

solution 1: version 2

class Solution {
    public int search(int[] arr, int key) {
        
    if(arr == null || arr.length == 0){
      return -1;
    }
    
    int left = 0, right = arr.length  -1;
    while(left <= right){
      int mid = left + (right - left)/2;
      int midVal = arr[mid];
      if(midVal == key){
        return mid;
      }
      
      if(midVal >= arr[left]){
        if(key >= arr[left] && key < midVal){
          right = mid -1;
        }else{
          left = mid + 1;
        }
      }else if(midVal <= arr[right]){
        if(key > midVal && key <= arr[right]){
          left = mid + 1;
        }else{
          right = mid -1;
        }
      
      }
    } 
    return -1;
    }
    
   
}


036. Valid Sudoku.txt

Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

A partially filled sudoku which is valid.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

Example 1:

Input:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true
Example 2:

Input:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being 
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
The given board contain only digits 1-9 and the character '.'.
The given board size is always 9x9.



class Solution {
    public boolean isValidSudoku(char[][] board) {
        for(int i = 0; i < 9; i++){
            Set<Character> rowSet = new HashSet<>();
            Set<Character> colSet = new HashSet<>();
            Set<Character> cubeSet = new HashSet<>();
            
            for(int j = 0; j < 9; j++){
                if(board[i][j] !='.' && rowSet.add(board[i][j]) == false){
                    return false;
                }
                
                if(board[j][i] !='.' && colSet.add(board[j][i]) == false){
                    return false;
                }
                
                /**
                *This idea is very helpful, the way of how j%3 and j/3 is used to navigate through a single matrix, and then
                    use (i%3) * 3 to move the block horizontally, and (i /3) * 3 to move vertically down
                */
                int rowIndex = i/3*3 + j/3;
                int colIndex = i%3 *3 + j%3;
                if(board[rowIndex][colIndex] !='.' && cubeSet.add(board[rowIndex][colIndex]) == false){
                    return false;
                }
            }

        }
                    
        return true;
    }
}


038. Count and Say.txt

The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

Example 1:

Input: 1
Output: "1"
Example 2:

Input: 4
Output: "1211"

class Solution {
     /**
     * @param n: the nth
     * @return: the nth sequence
     */
    public String countAndSay(int n) {
        // write your code here
        if(n == 0) return "0";
        if(n == 1) return "1";
        String dp[] = new String[n+1];
        dp[1] = "1";
        dp[2] = "11";
        
        for(int i = 3; i < n+1; i++){
            dp[i] = countAndSayHelper(dp[i-1]);
        }
        
        return dp[n];
        
        
    }
    
    public String countAndSayHelper(String val){
        char a[] = val.toCharArray();
        StringBuilder sb = new StringBuilder();
        char prev = a[0];
        int count = 1;
        for(int i = 1; i < val.length(); i++){
            if(a[i] == a[i-1]){
                count++;
            }else{
                sb.append(count).append(prev);
                prev = a[i];
                count= 1;
            }
            
            if(i == val.length() -1){
                sb.append(count).append(prev);
            }
        }
        
        return sb.toString();
    }
}


039. Combination Sum.txt

39. Combination Sum
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

solution:backtrack
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {

        List<List<Integer>> res = new ArrayList<>();
        if(candidates == null || candidates.length == 0) {
            return res;
        }
        backtrack(res, new ArrayList<Integer>(), candidates, 0, target);
        return res;
    }
    
    private void backtrack(List<List<Integer>> res, List<Integer> currList, int candidates[], int pos, int target){
        if(pos >= candidates.length || target < 0){
            return;
        }
        
        if(target == 0){
            res.add(new ArrayList<>(currList));
            return;
        }
        for(int i = pos; i < candidates.length; i++){
            currList.add(candidates[i]);
            backtrack(res, currList, candidates, i, target - candidates[i]);
            currList.remove(currList.size()-1);
        }
        
        
    }
}

045. Jump Game II.txt

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

Example:

Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
Note:

You can assume that you can always reach the last index.

Solution 1: O(n*n) dp - time limit exceeding
class Solution {
    public int jump(int[] nums) {
        int dp[] = new int[nums.length];
        
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for(int i = 1; i < nums.length;i++){
            for(int j = 0; j < i; j++){
                if(dp[j] != Integer.MAX_VALUE && nums[j] >= (i-j)){
                    dp[i] = Math.min(dp[i], dp[j] +1);
                }
            }            
        }
        
        return dp[nums.length -1];
        
        
    }
}

solution 2: Greedy
class Solution {
    public int jump(int[] nums) {
       
        int res = 0;
        int curr = 0, farthest = 0;
        
        for(int i = 0; i < nums.length; i++){
            
            if(curr < i){
                res++;
                curr = farthest; 
            }
            farthest = Math.max(farthest, nums[i] + i);
        }
        
        return res;
    }
}


046. Permutations.txt

Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

public class Solution {
    /*
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public List<List<Integer>> permute(int[] nums) {
        // write your code here
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0){
            res.add(new ArrayList<>());
            return res;
        }
        
        boolean used[] = new boolean[nums.length];
        
        backtrack(res, new ArrayList<Integer>(), nums, used);
        
        return res;
    }
    
    public void backtrack(List<List<Integer>> res, List<Integer> currList, int[] nums, boolean[] used){
        if(currList.size() == nums.length){
            res.add(new ArrayList<>(currList));
        }else{
            for(int i = 0; i < nums.length; i++){
                if(used[i]){
                  continue;
                }
                used[i] = true;
                currList.add(nums[i]);
                backtrack(res, currList, nums, used);
                currList.remove(currList.size()-1);
                used[i] = false;
                
            }
        }
        
        
    }
}


047. Permutations. II.txt

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]


class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0) return res;
        
        Arrays.sort(nums);
        boolean status[] = new boolean[nums.length];
        backtrack(res, new ArrayList<Integer>(),nums,status);
        return res;
    }
    
    private void backtrack(List<List<Integer>> res, List<Integer> currList, int[] nums, boolean status[]){
        if(currList.size() == nums.length){
            res.add(new ArrayList<Integer>(currList));
        }else{
            for(int i = 0; i < nums.length; i++){
                /*
                上面的判断主要是为了去除重复元素影响。
                比如，给出一个排好序的数组，[1,2,2]，那么第一个2和第二2如果在结果中互换位置，
                我们也认为是同一种方案，所以我们强制要求相同的数字，原来排在前面的，在结果
                当中也应该排在前面，这样就保证了唯一性。所以当前面的2还没有使用的时候，就
                不应该让后面的2使用。
                */
                if(status[i] || (i > 0 && nums[i] == nums[i-1] && status[i-1] == false)) continue;
                status[i] = true;
                currList.add(nums[i]);
                backtrack(res, currList,nums, status);
                currList.remove(currList.size()-1);
                status[i] = false;
            }
            
        }
        
    }
}


048. Rotate Image.txt

You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

class Solution {
    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0){
            return;
        }
        
        int n = matrix.length;
        for(int r = 0; r < n/2; r++){
            for(int c = r; c < n - r -1 ; c++){
                int temp = matrix[r][c];
                matrix[r][c] = matrix[n-1-c][r];
                matrix[n-1-c][r] = matrix[n-1-r][n-1-c];
                matrix[n-1-r][n-1-c] = matrix[c][n-1-r];
                matrix[c][n-1-r] = temp;
                
            }
        }
        
    }
}

050. Pow(x, n).txt

Implement pow(x, n), which calculates x raised to the power n (xn).

Example 1:

Input: 2.00000, 10
Output: 1024.00000
Example 2:

Input: 2.10000, 3
Output: 9.26100
Example 3:

Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
Note:

-100.0 < x < 100.0
n is a 32-bit signed integer, within the range [−231, 231 − 1]

class Solution {
    public double myPow(double x, int n) {
        if(n == 0){
            return 1;
        }
        if(n == 1){
            return x;
        }
        
        if (n == Integer.MIN_VALUE) {
            return (1 / x) * myPow(x, n+1);
        }
        
        double res;
        if(n < 0){
            n = -n;
            x = 1/x;
        }
        
        double temp = myPow(x, n/2);
        if(n %2 == 0){
            res = temp * temp;
        }else{
            res = x * temp * temp;
        }
        
        return res;
        
        
    }
    
}


053. Maximum Subarray.txt

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        
        int max = Integer.MIN_VALUE;
        int subSum = 0;
        
        for(int i = 0; i < nums.length; i++){
        
            if(nums[i] > subSum + nums[i]){
                subSum = nums[i];
            }else{
                subSum = subSum + nums[i];
            }
            
             max = Math.max(subSum, max);
        
        }
        
        return max;
        
    }
}

class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        
        
        int subSum = nums[0];
        int max =  subSum;
        
        for(int i= 1; i < nums.length; i++){
            int num = nums[i];
            if(subSum + num <= num){
                subSum = num;
            }else{
                subSum += num;
            }
            
            max = Math.max(max, subSum);
        }
        
        return max;
        
    }
}


054. Spiral Matrix.txt

Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if(matrix == null || matrix.length== 0 || matrix[0].length == 0){
            return res;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int colStart = 0, colEnd = cols -1, rowStart = 0, rowEnd = rows -1;
        
        while(colStart <= colEnd && rowStart <= rowEnd){
            for(int col = colStart; col <= colEnd; col++){
                res.add(matrix[rowStart][col]);
            }
            
            rowStart++;
            
            for(int row = rowStart; row <= rowEnd; row++){
                res.add(matrix[row][colEnd]);
            }
            
            colEnd--;
            
            if(rowStart <= rowEnd){
                for(int col = colEnd; col >=colStart; col--){
                    res.add(matrix[rowEnd][col]);
                }
            }
            
            rowEnd--;
            
            if(colStart <= colEnd){
                for(int row = rowEnd; row >= rowStart; row--){
                    res.add(matrix[row][colStart]);
                }
            }
            
            colStart++;
        }
        
        return res;
        
    }
}


055. Jump Game.txt

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
solution 1: dp O(n *n)
class Solution {
    public boolean canJump(int[] nums) {
        
        int len  = nums.length;
        boolean dp[] = new boolean[len+1];
        dp[0] = true;
        
        for(int i = 1; i < len; i++){
            for(int j = 0; j < i; j++){
               if(dp[j] && nums[j] >= (i-j)){
                   dp[i] = true;
                   break;
               } 
            }
            
        }
        
        return dp[len-1];
            
    }
}

solution 2: greedy O(n)
class Solution {
    public boolean canJump(int[] nums) {
        
        int pos = 0, len = nums.length;
        
        for(int i = 0; i < len; i++){
            if(i <= pos){
                pos = Math.max(pos, i + nums[i]); 
            }
        }
        
        return pos >= len - 1;
        
    }
}


056. Merge Intervals.txt

Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considerred overlapping.

/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> res = new ArrayList<>();
        if(intervals == null || intervals.size() < 2){
            return intervals;
        }
        
        Comparator<Interval> comparator = new Comparator<Interval>(){
            @Override
            public int compare(Interval i1, Interval i2){
                if(i1.start == i2.start){
                    return i1.end - i2.end;
                }
                
                return i1.start - i2.start;
            }
        };
        Collections.sort(intervals, comparator);
        
        Interval prev = intervals.get(0);
        for(int i = 1; i < intervals.size();i++){
            Interval curr = intervals.get(i);
            if(curr.start <= prev.end){
                prev.end = Math.max(prev.end,curr.end);
                
            }else{
                res.add(prev);
                prev = curr;
            }
            
            if(i == intervals.size() -1){
                res.add(prev);
            }
        }
        
        return res;
    }
}


070. Climbing Stairs.txt

70. Climbing Stairs
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

solution 1: memorization + recursion
class Solution {
    public int climbStairs(int n) {
        if(n <=3){
            return n;
        }
        
        int mem[] = new int[n+1];
        Arrays.fill(mem, -1);
        mem[0] = 1;
        mem[1] = 1;
        mem[2] = 2;
        mem[3] = 3;
        return helper(n, mem);
       
    }
    
    public int helper(int n, int[] mem){
        if(mem[n] != -1){
            return mem[n];
        }
        
        mem[n] = helper(n-1, mem) + helper(n-2, mem);
        return mem[n];
    }
}

solutin 2: dp
class Solution {
    public int climbStairs(int n) {
        if(n <=3){
            return n;
        }
        
        int dp[] = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        
        for(int i =3 ; i< n+1; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
    
}




071. Simplify Path.txt

Given an absolute path for a file (Unix-style), simplify it.

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"

Corner Cases:

Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".


class Solution {
    public String simplifyPath(String path) {
        if(path == null || path.length() <= 1 ){
            return "/";
        }
        
        String subpaths[] = path.split("\\/");
        System.out.println(Arrays.toString(subpaths));
        Stack<String> stack = new Stack<>();
        
        for(String subpath: subpaths){
            if(subpath.isEmpty() || subpath.trim()=="" || subpath.equals(".")){
                continue;
            }
            
            if(subpath.equals("..") ){
                if( !stack.isEmpty()){
                    stack.pop();
                }
            }else{
                stack.add(subpath);
            }
        }
        
        if(stack.isEmpty()){
            return "/";
        }
        
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()){
            sb.insert(0,stack.pop());
            sb.insert(0,'/');
        }
        
        return sb.toString();
        
    }
}

076. Minimum Window Substring.txt

76. Minimum Window Substring
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
Note:

If there is no such window in S that covers all characters in T, return the empty string "".
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.

solution: sliding window
class Solution {
    public String minWindow(String s, String t) {
        if(s == null ||s.length() == 0 || t == null || t.length() == 0){
            return "";
        }
        
        int min = Integer.MAX_VALUE;
        String res="";
        int left = 0, right = 0;
        int hash[] = new int[256];
        int count = 0;
        for(int i = 0; i < t.length(); i++){
            hash[t.charAt(i)]++;
            count++;
        }
        
        while(right < s.length()){
            if(hash[s.charAt(right)] >= 1){
                count--;
            }
            
            hash[s.charAt(right)]--;
            right++;
            
            while(count == 0){
                if(min > (right - left)){
                    min = right - left;
                    res = s.substring(left, right);
                }
                
                if(hash[s.charAt(left)] >= 0){
                    count++;
                }
                
                hash[s.charAt(left)]++;
                left++;
            }
        }
        
        return res;
        
        
        
    }
}


078. Subsets.txt

Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

solution: backtrack
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0){
            return res;
        }
        
        backtrack(res, nums, new ArrayList<Integer>(),0);
        return res;
    }
    
    private void backtrack(List<List<Integer>> res, int[] nums, List<Integer> currList, int start){
         res.add(new ArrayList<Integer>(currList));
        
         if(start == nums.length){
            return;
        }
        
        for(int i = start; i < nums.length; i++){
            currList.add(nums[i]);
            backtrack(res, nums, currList,i+1);
            currList.remove(currList.size()-1);
        }
        
    }
}


079. Word Search.txt

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.

solution 1: dfs + backtrack (version 1)
class Solution {
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    public boolean exist(char[][] board, String word) {
        if(board == null || board.length == 0) return false;
        if(word == null || word.length() == 0) return true;
        int rows = board.length;
        int cols = board[0].length;
        boolean status[][] = new boolean[rows][cols];
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                if(dfs(board, word,status, row, col, 0)){
                    return true;
                }
            }
        }
        
        return false;
    }
    
    public boolean dfs(char[][] board, String word, boolean status[][], int row, int col, int currPos){
        if(currPos == word.length()) return true;
        
        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || status[row][col]){
            return false;
        }
        
        if(board[row][col] != word.charAt(currPos)) return false;
        
        status[row][col] = true;
        
        for(int dir[]: dirs){
            if(dfs(board, word, status, row + dir[0], col + dir[1], currPos+1)){
                return true;
            }
        }
        status[row][col] = false;
        return false;
    }
}

solution 1: dfs + backtrack

class Solution {
    int dirs[][] = {{0, -1},{-1,0},{0, 1},{1, 0}};
    
    public boolean exist(char[][] board, String word) {
        if(board == null || board.length == 0 || word == null || word.length() == 0){
            return false;
        }
        int rows = board.length;
        int cols = board[0].length;
        int status[][] = new int[rows][cols];
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){

                if(dfs(row, col, rows,cols,board, word,0, status) == true){
                   return true;
               }
                
            }
        }
        
        return false;
    }
    
    private boolean dfs(int row, int col, int rows, int cols, char[][] board, String word, int curr, int status[][]){
        if(curr == word.length()){
            return true;
        }else{
             if(row < 0 || row >= rows || col < 0 || col >= cols){
                return false;
             }
            
             if(status[row][col] == 0 && board[row][col] == word.charAt(curr)){    
                 status[row][col] = 1;
                 for(int dir[]: dirs){
                     int newRow = row + dir[0];
                     int newCol = col + dir[1];
                    
                    if(dfs(newRow, newCol,rows, cols, board, word, curr+1, status)){
                        return true;
                    }
            
                 }
                 status[row][col] = 0;
            }
          
            return false;
        }
    }
}


solution 2: trie
public class Solution {
    
    class Trie{
        Trie children[] = new Trie[256];
        boolean isEnd = false;
    }
    
    Trie root = new Trie();
    
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    
    private void loadTrie(String word){
        Trie curr = root;
        
        for(char c: word.toCharArray()){
            if(curr.children[c] == null){
                curr.children[c] =  new Trie();
            }
            
            curr = curr.children[c];
        }
        
        curr.isEnd = true;
        
    }
    /**
     * @param board: A list of lists of character
     * @param word: A string
     * @return: A boolean
     */
    public boolean exist(char[][] board, String word) {
        // write your code here

        int rows = board.length;
        int cols = board[0].length;
        int status[][] = new int[rows][cols];
        loadTrie(word);
        
        for(int row = 0 ; row < rows ; row++){
            for(int col = 0; col < cols; col++){
                if(dfs(board, root, row,col, status)){
                    return true;
                }
            }
        }

        return false;
    }
    
    public boolean dfs(char[][] board, Trie trie, int row, int col, int status[][]){

        if(row < 0 || row  >=board.length || col < 0 || col >= board[0].length || status[row][col] == 1){
            return false;
        }
        
        char currChar = board[row][col];
        
        if(trie.children[currChar] == null){
            return false;
        }
        
        trie = trie.children[currChar];
        if(trie.isEnd){
            return true;
        }
        
        status[row][col] = 1;
        for(int dir[]: dirs ){
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            
            if(dfs(board, trie, newRow, newCol, status)){
                return true;
            }
            
        }
        status[row][col] = 0;
        
        return false;
        
    }
}


088. Merge Sorted Array.txt

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int newLen = m + n;
        int index1 = m-1, index2 = n-1;
        
        for(int i = newLen-1; i >=0; i--){
            if(index1 >= 0 && index2>=0){
                if(nums1[index1] <= nums2[index2]){
                    nums1[i] = nums2[index2];
                    index2--;
                }else{
                    nums1[i] = nums1[index1];
                    index1--;
                }
            }else{
                if(index1 < 0){
                    nums1[i] = nums2[index2];
                    index2--;
                }else{
                   return;
                }
            }
        }
    }
}


public class Solution {
    /*
     * @param A: sorted integer array A which has m elements, but size of A is m+n
     * @param m: An integer
     * @param B: sorted integer array B which has n elements
     * @param n: An integer
     * @return: nothing
     */
    public void mergeSortedArray(int[] A, int m, int[] B, int n) {
        // write your code here
        
        int indexA = m-1, indexB= n-1, index = m+n-1;
        
        while(indexA >=0 && indexB >= 0){
            if(A[indexA] <= B[indexB]){
                A[index--] = B[indexB--];
            }else{
                A[index--] = A[indexA--];
            }
        }
        
        if(indexA >=0 ){
            return;
        }
        
        while(indexB >= 0){
            A[index--] = B[indexB--];
        }
        

    }
}


089. Gray Code.txt

The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

00 - 0
01 - 1
11 - 3
10 - 2
Note:
For a given n, a gray code sequence is not uniquely defined.

For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about th

思路：

例举grey code序列，并找规律 :
n = 0: 0
n = 1: 0, 1
n = 2: 00, 01, 11, 10  (0, 1, 3, 2)
n = 3: 000, 001, 011, 010, 110, 111, 101, 100 (0, 1, 3, 2, 6, 7, 5, 4)
以n = 3为例，grey code中前4个包括了n = 2的所有gray code。后4个则是前4个逆序后加上2^2。

推广：n = i的grey code的前一半包括了n = i-1的所有grey code，而后一半则为前一半逆序后家上2^(i-1)。

public class Solution {
    /**
     * @param n: a number
     * @return: Gray code
     */
    public List<Integer> grayCode(int n) {
        // write your code here
        List<Integer> res = new ArrayList<>();
        if(n == 0){
            res.add(0);
            return res;
        }
        
        if(n == 1){
            res.add(0);
            res.add(1);
            return res;
        }
        
        List<Integer> prevRes = grayCode(n-1);
        List<Integer> currRes = new ArrayList<>(prevRes);
        int addNum = 1 << (n - 1);
        
        for(int i = prevRes.size() -1; i >= 0; i--){
            currRes.add(addNum + prevRes.get(i));
        }
        
        return currRes;
        
    }
}


091. Decode Ways.txt

A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

class Solution {
    public int numDecodings(String s) {
        if(s == null || s.length() == 0) return 1;
        
        int len = s.length();
        
        int dp[] = new int[len+1];
        dp[0] = 1;
        dp[1] = s.charAt(0) == '0'?0:1;
        
        for(int i = 2; i < len+1; i++){
            int first = Integer.valueOf(s.substring(i-1,i));
            int second = Integer.valueOf(s.substring(i-2,i));
            
            if(first != 0){
                dp[i] += dp[i-1];
            }
            
            if(second >= 10 && second <=26){
                dp[i] += dp[i-2];
            }
        
        }
        
        return dp[len];
    }
}


092. Reverse Linked List II.txt

Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?

http://blog.leanote.com/post/liuliu5151@gmail.com/Reverse-Linked-List-II-2


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        
        if(head == null || head.next == null){
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        ListNode preM = dummy;
        ListNode mNode = head;
        ListNode nNode = head;
        for(int i = 1; i < m; i++){
            preM = mNode;
            mNode = mNode.next;
        }
        
        for(int i = 1; i < n; i++){
            nNode = nNode.next;
        }
        
        while(mNode != nNode){
            preM.next = mNode.next;
            mNode.next = nNode.next;
            nNode.next = mNode;
            mNode = preM.next;
        }
        
        return dummy.next;
    }
}


094. Binary Tree Inorder Traversal.txt

Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        
        while(!stack.isEmpty() || curr != null){
            while(curr != null){
                stack.push(curr);
                curr = curr.left;
            }
            
            curr = stack.pop();
            res.add(curr.val);
            
            curr = curr.right;
        }
        
        return res;
        
    }
}


098. Validate Binary Search Tree.txt

98. Validate Binary Search Tree
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:

Input:
    2
   / \
  1   3
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.

solution:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 solution 1: min and max check
class Solution {
    public boolean isValidBST(TreeNode root) {
        
        if(root == null){
            return true;
        }
        
        return validate(root, null, null);
        
    }
    
    public boolean validate(TreeNode root, Integer min, Integer max){
        if(root == null){
            return true;
        }
        
        return (min == null || root.val > min) && (max == null || root.val < max) && validate(root.left, min, root.val) && 
            validate(root.right, root.val, max);
        
    }
}

#solution 2: inorder search with recursion
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode prev;
    
    public boolean isValidBST(TreeNode root) {
        return inOrder(root);
    }
    
    private boolean inOrder(TreeNode root){
        if(root == null){
            return true;
        }
        
        if(inOrder(root.left) == false){
            return false;
        }
        
        if(prev == null){
            prev = root;
        }else{
            if(root.val <= prev.val){
                return false;
            }else{
                prev = root;
            }
        }
        
        if(inOrder(root.right) == false){
            return false;
        }
        
        return true;
        
    }
}

#solution 3: in order search with iteration
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode prev;
    
    public boolean isValidBST(TreeNode root) {
        return inOrder(root);
    }
    
    private boolean inOrder(TreeNode root){
        if(root == null){
            return true;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        
        while(!stack.isEmpty() || curr != null){
            while(curr != null){
                stack.push(curr);
                curr = curr.left;
            } 
            
            curr = stack.pop();
            if(prev == null){
                prev = curr;
            }else{
                if(prev.val >= curr.val){
                    return false;
                }else{
                    prev = curr;
                }
            }
            
            curr = curr.right;
        }
        
        return true;
        
    }
}

101. Symmetric Tree.txt

 Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3

solution1: recursion
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        
        return helper(root.left, root.right);
    }
    
    private boolean helper(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }else if(left != null && right != null){
            return left.val == right.val && helper(left.right, right.left) && helper(left.left, right.right);
        }
        
        return false;
    }
}

solution 2: iteration using two queues
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        
        Queue<TreeNode> q1 = new LinkedList<>();
        Queue<TreeNode> q2 = new LinkedList<>();
        q1.add(root);
        q2.add(root);
        while(!q1.isEmpty() && !q2.isEmpty()){
            TreeNode curr1 = q1.remove();
            TreeNode curr2 = q2.remove();
            if(curr1 == null && curr2 == null){
                continue;
            }else if(curr1 != null && curr2 !=null){
                if(curr1.val != curr2.val){
                    return false;
                }
                
                q1.add(curr1.left);
                q1.add(curr1.right);
                q2.add(curr2.right);
                q2.add(curr2.left);
                
            }else{
                return false;
            }
            
        }
        
        return q1.isEmpty() && q2.isEmpty();
        
    }
}   


102. Binary Tree Level Order Traversal.txt

102. Binary Tree Level Order Traversal
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]

solution 1: manually check levelcount, next level count
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        int levelCount = 0;
        int nextLevelCount = 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        levelCount = 1;
        List<Integer> levelList = new ArrayList<>();
        
        while(!q.isEmpty()){
            if(levelCount> 0){
                TreeNode curr = q.remove();
                levelCount--;
                levelList.add(curr.val);
                if(curr.left != null){
                    q.add(curr.left);
                    nextLevelCount++;
                }
                
                if(curr.right != null){
                    q.add(curr.right);
                    nextLevelCount++;
                }
            }
            
            if (levelCount == 0){
                levelCount = nextLevelCount;
              
                nextLevelCount = 0;
                res.add(levelList);
                levelList = new ArrayList<>();
            }
           
        }
        
        return res;
        
    }
}

#solution 2: using queue.size
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> levelList = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode curr = q.remove();
                levelList.add(curr.val);
                if(curr.left != null){
                    q.add(curr.left);
                }
                
                if(curr.right != null){
                    q.add(curr.right);
                }
            }
            res.add(levelList);
        }
        
        return res;
        
    }
}

103. Binary Tree Zigzag Level Order Traversal.txt

Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        
        boolean inorder = true;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> currList = new LinkedList<>();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.remove();
                if(inorder){
                    currList.add(curr.val);
                }else{
                    currList.add(0, curr.val);
                }
                
                if(curr.left != null) queue.add(curr.left);
                if(curr.right !=null) queue.add(curr.right);
            }
            res.add(currList);
            inorder = !inorder;
        }
        
        return res;  
    }
}


105. Construct Binary Tree from Preorder and Inorder Traversal.txt

Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
solution 1: easy to figure out version, tracking from 0
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder == null || preorder.length == 0 || inorder == null || inorder.length == 0) return null;
        
        return buildTreeHelper(preorder, inorder, 0, preorder.length-1,0);
    }
    
    public TreeNode buildTreeHelper(int[] preorder, int[] inorder, int start, int end, int preorderIndex){
        if(start > end) return null;
        TreeNode root = new TreeNode(preorder[preorderIndex]);
        int mid = findNode(root.val, inorder, start, end);
        int leftTreeSize = mid - start;
        int rightTreeSize = end - mid;
        root.left = buildTreeHelper(preorder, inorder, start, mid-1, preorderIndex+1);
        root.right = buildTreeHelper(preorder,inorder, mid+1, end,preorderIndex + leftTreeSize+1);
        return root;
        
    }
    
    private int findNode(int val, int[] inorder, int start, int end){
        for(int i = start; i <= end ; i++){
            if(val == inorder[i]){
                return i;
            }
        }
        return -1;
        
    }
}

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int currPreOrderIndex = 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder == null || preorder.length == 0 || inorder == null || inorder.length == 0) return null;
        
        return buildTreeHelper(preorder, inorder, 0, preorder.length-1);
    }
    
    public TreeNode buildTreeHelper(int[] preorder, int[] inorder, int start, int end){
        if(start > end) return null;
        TreeNode root = new TreeNode(preorder[currPreOrderIndex++]);
        int mid = findNode(root.val, inorder, start, end);
        
        root.left = buildTreeHelper(preorder, inorder, start, mid-1);
        root.right = buildTreeHelper(preorder,inorder, mid+1, end);
        return root;
        
    }
    
    private int findNode(int val, int[] inorder, int start, int end){
        for(int i = start; i <= end ; i++){
            if(val == inorder[i]){
                return i;
            }
        }
        return -1;
        
    }
}


106. Construct Binary Tree from Inorder and Postorder Traversal.txt

Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
 
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        
       if(postorder == null || postorder.length == 0 || inorder == null || inorder.length == 0) return null;
        
        return buildTreeHelper(postorder, inorder,  0, postorder.length-1, postorder.length-1);
    }
    
    public TreeNode buildTreeHelper(int[] postorder, int[] inorder, int start, int end, int postend){
        if(start > end) return null;
        TreeNode root = new TreeNode(postorder[postend]);
        int mid = findNode(root.val, inorder, start, end);
        int leftTreeSize = mid - start;
        int rightTreeSize = end - mid;
        root.right = buildTreeHelper(postorder,inorder, mid+1, end, postend-1 );
        root.left = buildTreeHelper(postorder, inorder, start, mid-1, postend - rightTreeSize -1 );

        return root;
        
    }
    
    private int findNode(int val, int[] inorder, int start, int end){
        for(int i = start; i <= end ; i++){
            if(val == inorder[i]){
                return i;
            }
        }
        return -1;
        
    }
}


108. Convert Sorted Array to Binary Search Tree.txt

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
 
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null || nums.length ==0){
            return null;
        }
        
        int len = nums.length;
        return sortedArrayToBSTRec(nums, 0, len-1);
    }
    
    public TreeNode sortedArrayToBSTRec(int[] nums, int start, int end){
        if(start > end){
            return null;
        }
        
        int mid = start + (end - start)/2;
        TreeNode root =  new TreeNode(nums[mid]);
        root.left = sortedArrayToBSTRec(nums, start, mid -1);
        root.right = sortedArrayToBSTRec(nums, mid+1, end);
        return root;
        
    }
}


109. Convert Sorted List to Binary Search Tree.txt

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
  ListNode currNode;
    public TreeNode sortedListToBST(ListNode head) {
       // write your code here
        if(head == null){
            return null;
        }
        currNode = head;
        ListNode pointer = head;
        int n = 0;
        while(pointer != null){
            n++;
            pointer = pointer.next;
        }
        
        return sortedListToBSTRecur(0, n-1);
        
            
    }

                             
     private TreeNode sortedListToBSTRecur(int start, int end){
        if(start > end){
            return null;
        }
        
        int mid = start + (end - start)/2;
        TreeNode left = sortedListToBSTRecur(start, mid -1);
        TreeNode root = new TreeNode(currNode.val);
        root.left = left;
        currNode = currNode.next;
        root.right = sortedListToBSTRecur(mid +1 ,end);

        return root;
        
    }
}
                                       


114. Flatten Binary Tree to Linked List.txt

Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6

Solution 1: PreOrder
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if(root == null){
            return;
        }
        TreeNode dummy = new TreeNode(-1);
        TreeNode head = dummy;
        Stack<TreeNode> stack = new Stack<>();        
        stack.add(root);
        
        while(!stack.isEmpty()){
            
            TreeNode curr = stack.pop();
            head.right = curr;
            head.left = null;
            head = head.right;
            if(curr.right != null){
                stack.add(curr.right);
            }
            
            if(curr.left != null){
                stack.add(curr.left);
            }
            
        }
    }
}

/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */

solution 2:Go down through the left, when right is not null, push right to stack.
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void flatten(TreeNode root) {
        // write your code here
        if(root == null){
            return;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        
        while(!stack.isEmpty() || curr != null){
            if(curr.right != null){
                stack.push(curr.right);
            }
            
            if(curr.left != null){
                curr.right = curr.left;
                curr.left = null;
            }else if(!stack.isEmpty()){
                TreeNode temp = stack.pop();
                curr.right = temp;
            }
           
           curr = curr.right;
        }
        
    }
    
    
}


119. Pascal's Triangle II.txt

Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.

Note that the row index starts from 0.


In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:

Input: 3
Output: [1,3,3,1]
Follow up:

Could you optimize your algorithm to use only O(k) extra space?

class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>();
        if(rowIndex < 0){
            return res;
        }
        
        for(int i = 0; i <= rowIndex; i++){
            res.add(1);
            
            for(int j = i - 1; j > 0; j--){
                res.set(j, res.get(j-1) + res.get(j));
            }
        }
        return res;
    }
}


120. Triangle.txt

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        
        int rows = triangle.size();
        int cols = rows;
        int dp[][] = new int[rows][cols];
        dp[0][0] = triangle.get(0).get(0);
        for(int i = 1; i < rows; i++){
            dp[i][0] = dp[i-1][0] + triangle.get(i).get(0);
            dp[i][i] = dp[i-1][i-1] + triangle.get(i).get(i);
        }
        for(int i = 1; i < rows; i++){
            for(int j = 1; j < i; j++){
                dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i-1][j], dp[i-1][j-1]);
            }
        }
        
        int res = Integer.MAX_VALUE;
        for(int i = 0; i < cols; i++){
            res = Math.min(res, dp[rows-1][i]);
        }
        
        return res;
        
        
    }
}


121. Best Time to Buy and Sell Stock.txt

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.

class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length == 0){
            return 0;
        }
        int min = Integer.MAX_VALUE;
        int maxDiff = Integer.MIN_VALUE;
        for(int price: prices){
            min = Math.min(price, min);
            maxDiff = Math.max(maxDiff, price - min);
        }
        
        return maxDiff;
    }
}


122. Best Time to Buy and Sell Stock II.txt

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.

class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        if(prices == null || prices.length == 0){
           return res;
        }
        
        int valley = prices[0];
        int peak = prices[0];
        int index = 0;
        int len = prices.length;
        while(index < len-1){
            while(index < len-1 && prices[index] > prices[index+1]){
                index++;
            }
            valley = prices[index];
            
            while(index < len - 1 && prices[index] < prices[index+1]){
                index++;
            }
            peak = prices[index];
            res += peak - valley;
            index++;
        }
        
        return res;
    }
}


124. Binary Tree Maximum Path Sum.txt

Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
Time Complexity: O(n)
class Solution {
    private int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxPathSumRec(root);
        return max;
    }
    
    public int maxPathSumRec(TreeNode root){
        if(root == null) return 0;
        
        int leftSum = maxPathSumRec(root.left);
        int rightSum = maxPathSumRec(root.right);

        max = Math.max(max, root.val + leftSum + rightSum);
        
        int sum = Math.max(leftSum + root.val, rightSum + root.val); 
        return sum <=0? 0: sum;
    }
}


125. Valid Palindrome.txt

 Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: "A man, a plan, a canal: Panama"
Output: true
Example 2:

Input: "race a car"
Output: false

 
 if(s == null || s.length() == 0) return true;
        
        char chars[] = s.toCharArray();
        int left = 0, right =chars.length-1;
        
        while(left < right){
            while(left < right && !Character.isLetterOrDigit(chars[left])) left++;
            while(left < right && !Character.isLetterOrDigit(chars[right])) right--;
            
            if(left < right){
                if(Character.toLowerCase(chars[left]) == Character.toLowerCase(chars[right])){
                    left++;
                    right--;
                }
                else{
                    return false;
                }
            }
        }
        
        return true;


126 Word Ladder II.txt

#126 Word Ladder II
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

solution: bfs+dfs+backtrack,26 letters,visted and unvisited

class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        List<List<String>> res = new ArrayList<>();
        if(wordList == null || wordList.size()==0){
            return res;
        }
        
        Set<String> unVisited= new HashSet<>(wordList);
        Set<String> visited = new HashSet<>();
        Map<String,List<String>> map = new HashMap();
        Queue<String> queue = new LinkedList<>();
        queue.add(beginWord);
        
        while(!queue.isEmpty()){
            int size= queue.size();
            
            for(int i = 0; i < size; i++){
                if(i == 0){
                    unVisited.removeAll(visited);
                    visited.clear();
                }
                
                String word = queue.remove();
                char chars[] = word.toCharArray();
                char temp; 
                for(int j = 0; j < chars.length;j++){
                    temp = chars[j];
                    for(char c='a'; c < 'z';c++){
                        if(temp == c){
                            continue;
                        }
                        chars[j] =c;
                        String newWord = new String(chars);
                        if(unVisited.contains(newWord)){
                            if(visited.add(newWord)){
                                queue.add(newWord);
                            }
                            
                            if(!map.containsKey(newWord)){
                                map.put(newWord, new ArrayList<String>());
                            }
                            
                            map.get(newWord).add(word);
                        }
                    }
                    chars[j] = temp;
                
                }
                
            }
        }
        
        System.out.println(Arrays.toString(map.entrySet().toArray()));
        dfs(res, new ArrayList<String>(), map,endWord,beginWord);
        return res;
    }
    
    public void dfs(List<List<String>> res,List<String> currList, Map<String,List<String>> map, String word, String beginWord){
        if(word.equals(beginWord)){
            currList.add(0,word);
            res.add(new ArrayList<>(currList));
            currList.remove(0);
        }else{
            if(!currList.contains(word)){
                currList.add(0,word);
                if(map.containsKey(word)){
                    for(String newWord: map.get(word)){
                        dfs(res,currList,map, newWord,beginWord);
                    }
                }
                currList.remove(0);
            }
        }
        
    }
}

127. Word Ladder.txt

127. Word Ladder

Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

solution 1: bfs, go through all 26 letters
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        int len = 0;
        if(wordList == null || wordList.size() == 0){
            return len;
        }
        
        Set<String> wordSet = new HashSet<>(wordList);
        Queue<String> queue = new LinkedList<>();
        queue.add(beginWord);
        len = 1;
        
        while(!queue.isEmpty()){
            int size = queue.size();
            
            for(int i = 0; i < size; i++){
                
                String word = queue.remove();
                
                if(word.equals(endWord)){
                     return len;
                }
                
                char wordInChars[] = word.toCharArray();
                char temp;
                for(int j = 0 ; j < wordInChars.length; j++){
                    temp = wordInChars[j];
                    for(char c='a'; c<'z';c++){

                        wordInChars[j] = c;
                        String newWord = new String(wordInChars);
                        
                        if(!word.equals(newWord) && wordSet.contains(newWord)){
                            wordSet.remove(newWord);
                            queue.add(newWord);

                        }
                    }
                    
                    wordInChars[j] = temp;

                }

            }
            len++;
            
        }
         return 0;
    }
}


129. Sum Root to Leaf Numbers.txt

129. Sum Root to Leaf Numbers
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.

solution: bst
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null){
            return 0;
        }
        
        return sumToLeaf(0,root);
    }
    
    private int sumToLeaf(int accu, TreeNode root){
        if(root.left == null && root.right == null){
            return accu*10 + root.val;
        }else if(root.left != null && root.right != null){
            return sumToLeaf(accu*10+root.val, root.left) + sumToLeaf(accu*10 + root.val, root.right);
        }else if(root.left != null){
            return sumToLeaf(accu*10+root.val, root.left);
        }else{
            return sumToLeaf(accu*10 + root.val, root.right);
        }
    }
}


133. Clone Graph.txt

Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/
 
 
 /**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if(node == null){
            return node;
        }
        
        Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
        Stack<UndirectedGraphNode> stack = new Stack<>();
        stack.push(node);
        UndirectedGraphNode clonedRoot = new UndirectedGraphNode(node.label);
        map.put(node, clonedRoot);
        while(!stack.isEmpty()){
            UndirectedGraphNode curr = stack.pop();
            UndirectedGraphNode clonedCurr = map.get(curr);            
            for(UndirectedGraphNode neighbor: curr.neighbors){
                if(!map.containsKey(neighbor)){
                    map.put(neighbor, new UndirectedGraphNode(neighbor.label));
                    //only handle neighbor once to avoid sef-cycle
                     stack.push(neighbor);
                }
                
                clonedCurr.neighbors.add(map.get(neighbor));
                   

            }
        }
        
        return clonedRoot;
        
    }
}


134. Gas Station.txt

There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

Note:

If there exists a solution, it is guaranteed to be unique.
Both input arrays are non-empty and have the same length.
Each element in the input arrays is a non-negative integer.
Example 1:

Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:

Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        
        int tank = 0, len = gas.length;
        boolean successful = true;
        for(int start = 0; start < len; start++){
            tank = 0;
            successful = true;
            for(int dest = start; dest < start + len; dest++){
                int curr = dest%len;
                tank += gas[curr] - cost[curr];
                
                if(tank < 0){
                    if(curr > start){
                        start = curr;
                    }
                    successful = false;
                    break;
                }
            }
            
            if(successful) return start;
            
        }
        
        return -1;
        
    }
}


138. Copy List with Random Pointer.txt

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        RandomListNode curr = head;
        Map<RandomListNode, RandomListNode> map = new HashMap<>();
        
        while(curr != null){
            map.put(curr, new RandomListNode(curr.label));
            curr = curr.next;
        }
        
        curr = head;
        while(curr != null){
            RandomListNode newNode = map.get(curr);
            newNode.next = map.get(curr.next);
            newNode.random = map.get(curr.random);
            curr = curr.next;
        }
        
        return map.get(head);
    }
}

solution 2: next next, Time Complexity O(n), Space Complexity O(1)
/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        RandomListNode curr = head;
        RandomListNode dummy = new RandomListNode(-1);
        RandomListNode dummyHead = dummy;
        
        //first round, copy next
        while(curr != null){
            RandomListNode next = curr.next;
            
            RandomListNode copy = new RandomListNode(curr.label);
            curr.next = copy;
            copy.next = next;
            
            curr = next;
        }
        
        curr = head;
        while(curr != null){
            RandomListNode random = curr.random;
            if(random != null){
                curr.next.random = curr.random.next;
            }
            
            curr = curr.next.next;
        }
        
        curr = head;
        while(curr != null){
            RandomListNode next = curr.next.next;
            dummyHead.next = curr.next;
            dummyHead = dummyHead.next;
            
            curr.next = next;
            curr = curr.next;
        }
        
        return dummy.next;
    }
}


139. Word Break.txt

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false


#1 optimal solution 
class Solution {
    Map<String,Boolean> map = new HashMap<>();
    public boolean wordBreak(String s, List<String> wordDict) {
        
        if(s == null || s.length() == 0){
            return true;
        }

        if(wordDict.size() == 0){
            return false;
        }
        
        int maxLen = 0;
        for (String word: wordDict) {
            if (word.length() > maxLen) {
                maxLen = word.length();
            }
        }
        
        boolean dp[] = new boolean[s.length()+1];
        dp[0] = true;
        
        for(int i = 1; i <= s.length(); i++){
            for(int lastWordLen = 1; lastWordLen <=i && lastWordLen <=maxLen; lastWordLen++){
                if(dp[i-lastWordLen] && wordDict.contains(s.substring(i-lastWordLen, i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[s.length()];
    }
}

solution 2: start from 0, traditional dp solution
class Solution {
    Map<String,Boolean> map = new HashMap<>();
    public boolean wordBreak(String s, List<String> wordDict) {
        
        if(s == null || s.length() == 0){
            return true;
        }

        if(wordDict.size() == 0){
            return false;
        }
        
        boolean dp[] = new boolean[s.length()+1];
        dp[0] = true;
        
        for(int i = 1; i <= s.length(); i++){
            for(int j = 0; j <i; j++){
                if(dp[j] && wordDict.contains(s.substring(j, i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[s.length()];
    }
}

solutin 3: memorization
class Solution {
    Map<String,Boolean> map = new HashMap<>();
    public boolean wordBreak(String s, List<String> wordDict) {
        if(map.containsKey(s)){
            return map.get(s);
        }
        
        if(s == null || s.length() == 0){
            return true;
        }
        
        if(wordDict.size() == 0){
            return false;
        }
        
        for(int i = 0; i < s.length(); i++){
            if(wordBreak(s.substring(0, i),wordDict) && wordDict.contains(s.substring(i))){
                map.put(s, true);
                return true;
            }
        }
        
        map.put(s, false);
        return false;
    }
}


141. Linked List Cycle.txt

Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        
        ListNode slow = head.next , fast = head.next != null? head.next.next:null;
        
        while(slow != null && fast != null){
            if(slow == fast) return true;
            slow = slow.next;
            fast = fast.next != null? fast.next.next: null;
        }
        
        return false;
        
    }
}


146. LRU Cache.txt

Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

#solution 1: head, tail
class LRUCache {
    private class Node{
        int key;
        int val;
        Node prev;
        Node next;
        public Node(int val){
            this.val = val;
        }
    }
    
    private Map<Integer,Node> map = new HashMap<>();
    private Node head, tail;
    private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head = new Node(0);
        tail = new Node(0);
        head.prev = null;
        head.next = tail;
        tail.prev = head;
        tail.next = null;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            moveToTop(node);
            return node.val;
            
        }else{
            return -1;
        }
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node != null){
            node.val = value;
            moveToTop(node);
        }else{
            evict_if_applicable();
            node = new Node(value);
            node.key = key;
            map.put(key,node);
            addToTop(node);
        }
    }
    
    private void moveToTop(Node curr){
        deleteNode(curr);
        addToTop(curr);
    }
    private void deleteNode(Node curr){
        Node prev = curr.prev;
        Node next = curr.next;
        prev.next = next;
        next.prev = prev;
    }
    
    private void addToTop(Node curr){
        Node headNext = head.next;
        headNext.prev = curr;
        head.next = curr;
        curr.prev= head;
        curr.next = headNext;
    }
    
    private void evict_if_applicable(){
            if(map.size()>= capacity){
                Node last = tail.prev;
                deleteNode(last);
                map.remove(last.key);
            }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

solution 2: linkedList
class LRUCache {
    private class Node{
        int key;
        int val;
        
        public Node(int key, int val){
            this.key = key;
            this.val = val;
        }
    }
    
    Map<Integer, Node> cache;
    LinkedList<Node> cache_values;
    int capacity;
    
    public LRUCache(int capacity) {
        cache = new HashMap<>(capacity);
        cache_values = new LinkedList<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)){
            return -1;
        }
        
        Node node = cache.get(key);
        cache_values.remove(node);
        cache_values.addFirst(node);
        return node.val;
        
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        
        if(node == null){
            evictIfApplicable();
            node = new Node(key, value);
            cache.put(key,node);
            cache_values.addFirst(node);
        }else{
            node.val = value;
            cache_values.remove(node);
            cache_values.addFirst(node);
        }
    }
    
    private void evictIfApplicable(){
        if(cache.size() >= capacity){
            Node last = cache_values.removeLast();
            cache.remove(last.key);
        }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */


151. Reverse Words in a String.txt

Given an input string, reverse the string word by word.

Example:  

Input: "the sky is blue",
Output: "blue is sky the".
Note:

A word is defined as a sequence of non-space characters.
Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.
You need to reduce multiple spaces between two words to a single space in the reversed string.
Follow up: For C programmers, try to solve it in-place in O(1) space.

public class Solution {
    public String reverseWords(String s) {
        if(s == null) return null;
        if(s.length() <= 1) return s.trim();
        String words[] = s.split("\\s+");
        StringBuilder sb = new StringBuilder();
        for(int i= words.length-1; i>=0; i--){
            sb.append(words[i]);
            sb.append(" ");
        }
        
        return sb.toString().trim();
    }
}

public class Solution {
    /*
     * @param s: A string
     * @return: A string
     */
    public String reverseWords(String s) {
        // write your code here
        if(s == null) return s;
        
        if(s.length() < 2) {
            return s.trim();
        }
        
        char strs[] = s.toCharArray();
        int len = strs.length;
        
        reverse(strs,0, len -1);
        
        int left = 0, right= 0;
        
        for(int i = 0;i < len; i++){
            if(strs[i] != ' '){
                strs[right++] = strs[i];
                if(i == len -1){
                    reverse(strs, left, right-1);
                }
            }else if(i > 0 && strs[i-1] != ' '){
                reverse(strs, left, right-1);
                strs[right++] = ' ';
                left = right;
            }
        }
        
        int end = right >0 && strs[right-1] == ' '?right-1: right;
        return  new String(strs, 0, end);
    }
    
    private void reverse(char strs[], int left, int right){
        while(left < right){
            char temp = strs[left];
            strs[left++] = strs[right];
            strs[right--] = temp;
        }
    }
}


153. Find Minimum in Rotated Sorted Array.txt

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:

Input: [3,4,5,1,2] 
Output: 1
Example 2:

Input: [4,5,6,7,0,1,2]
Output: 0
solution 1: iteration
class Solution {
    public int findMin(int[] nums) {
        //if(nums == null || nums.length == 0) ;
        int len = nums.length;
        int left = 0, right = len -1;
        
        while(left+1 < right){
            int mid = left + (right-left)/2;
            
            if(nums[mid] > nums[left]){
                if(nums[mid] < nums[right]){
                    return nums[left];
                }else{
                    left = mid;
                }
            }else{
                right = mid;
            }
        }
        
        return Math.min(nums[left], nums[right]);
        
    }
}

solution 2: recursion -version 1:
class Solution {
    public int findMin(int[] nums) {
        //if(nums == null || nums.length == 0) ;
        int len = nums.length;
        int left = 0, right = len -1;
        return findMinRec(nums, left, right);
    }
    
    public int findMinRec(int[] nums, int left, int right){
        
        if(nums[left] <= nums[right]) return nums[left];
        
        int mid = left + (right-left)/2;
        
        if(nums[mid] >= nums[left]){
            return findMinRec(nums, mid+1, right);
        }
       
        return findMinRec(nums, left, mid);
    }
}

solution 2: recursion -version 2:
class Solution {
    public int findMin(int[] nums) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        
        return findMin(nums, 0, nums.length -1);
        
    }
    
    public int findMin(int[] nums, int start, int end){
        if(start > end){
            return Integer.MAX_VALUE;
        }
        
        int mid = start + (end - start)/2;
        
        if(nums[mid] >= nums[start]){
            if(nums[start] > nums[end]){
                return findMin(nums, mid+1, end);
            }else{
                return nums[start];
            }
        }
        
        if(nums[mid] <= nums[end]){
            if(nums[end] < nums[start]){
                return findMin(nums, start, mid);
            }else{
                return nums[start];
            }
        }
        
        return Integer.MAX_VALUE;
    }
}


156.Binary Tree Upside Down.txt

Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

Example
Given a binary tree {1,2,3,4,5}

    1
   / \
  2   3
 / \
4   5
return the root of the binary tree {4,5,2,#,#,3,1}.

   4
  / \
 5   2
    / \
   3   1  
   
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
solution:
//每次需要reset最右节点的left/right node，否则最后一层递归，递归到例子中的1节点时，返回前1节点的left/right node仍然为原来的值，而并不为NULL。
public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: new root
     */
    public TreeNode upsideDownBinaryTree(TreeNode root) {
        // write your code here
        if(root == null || root.left == null){
            return root;
        }
        
        TreeNode ret = upsideDownBinaryTree(root.left);
        root.left.left = root.right;
        root.left.right = root;
        root.left = null;
        root.right = null;
        return ret;
    }
}


158. Read N Characters Given Read4 II - Call multiple times.txt

The API: int read4(char *buf) reads 4 characters at a time from a file.

The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

Note:
The read function may be called multiple times.

Hide Company Tags  Bloomberg Google Facebook
Hide Tags  String


/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

public class Solution extends Reader4 {
    int pointer = 0;
    int count = 0;
    char temp[] = new char[4];
    /**
     * @param buf destination buffer
     * @param n maximum number of characters to read
     * @return the number of characters read
     */
    public int read(char[] buf, int n) {
        // Write your code here
        int index = 0;
        while(index < n){
            if(pointer == 0){
                count = read4(temp);
            }
            
            if(count == 0){
                break;
            }
            
            while(index < n && pointer < count){
                buf[index++] = temp[pointer++];
            }
            
            if(count == pointer){
                pointer = 0;
            }
            
        }
        return index;
    }
}



160. Intersection of Two Linked Lists.txt

160. Intersection of Two Linked Lists
Write a program to find the node at which the intersection of two singly linked lists begins.


For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
begin to intersect at node c1.


Notes:

If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null){
            return null;
        }
        int lenA = 0, lenB = 0;
        
        lenA = getLength(headA);
        lenB = getLength(headB);
        
        int diff = Math.abs(lenA - lenB);
        if(lenA > lenB){
            while(diff > 0){
                headA = headA.next;
                diff--;
            }        
        }else if(lenA < lenB){
            while(diff > 0){
                headB = headB.next;
                diff--;
            }  
        }
        
        while(headA != null && headB != null){
            if(headA == headB){
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }
        
        return null;
       
    }
    
    private int getLength(ListNode head){
        ListNode headCopy = head;
        int index = 0;
        while(headCopy != null){
            index++;
            headCopy = headCopy.next;
        }
        return index;
    }
}

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;      
 *     }
 * }
 */


public class Solution {
    /*
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // write your code here
        int lenA = getLength(headA);
        int lenB = getLength(headB);
        int diff = lenA - lenB;
        if(diff > 0){
            while(diff > 0){
                headA = headA.next;
                diff--;
            }
        }else if(diff < 0){
            while(diff < 0){
                headB = headB.next;
                diff++;
            }
        }
        
        while(headA != null && headB != null){
            if(headA == headB){
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }
        
        return null;
        
    }
    
    public int getLength(ListNode node){
        int len= 0;
        
        while(node != null){
            len++;
            node = node.next;
        }
        
        return len;
        
    }
}


162. Find Peak Element.txt

A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
Note:

Your solution should be in logarithmic complexity.

class Solution {
    public int findPeakElement(int[] nums) {
        
        int left = 0, right = nums.length -1;
        
        while(left + 1 < right){
            int mid = left + (right - left)/2;
            
            if(nums[mid] <= nums[mid+1]){
               left = mid+1; 
            }else{
                right = mid;
            }
        }
        
        return nums[left] > nums[right]?left:right;
        
    }
}


165. Compare Version Numbers.txt

Compare Version Numbers
Compare two version numbers version1 and version2.
If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Example 1:

Input: version1 = "0.1", version2 = "1.1"
Output: -1
Example 2:

Input: version1 = "1.0.1", version2 = "1"
Output: 1
Example 3:

Input: version1 = "7.5.2.4", version2 = "7.5.3"
Output: -1

solution: split it and fill with 0 if length is less

class Solution {
    public int compareVersion(String version1, String version2) {
        String v1s[] = version1.split("\\.");
        String v2s[] = version2.split("\\.");
        int v1Len = v1s.length;
        int v2Len = v2s.length;
        
        int maxLen = Math.max(v1Len, v2Len);
        for(int i=0;i< maxLen; i++){
            Integer subV1 = i >= v1Len? 0: Integer.valueOf(v1s[i]);
            Integer subV2 = i >= v2Len? 0: Integer.valueOf(v2s[i]);
            
            if(subV1.compareTo(subV2) != 0){
                return subV1.compareTo(subV2);
            }
            
        }
        
        return 0;  
      
    }
}

168. Excel Sheet Column Title.txt

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
Example 1:

Input: 1
Output: "A"
Example 2:

Input: 28
Output: "AB"
Example 3:

Input: 701
Output: "ZY"

class Solution {
    public String convertToTitle(int n) {
        StringBuilder sb = new StringBuilder();
        
        while(n> 0){
            n--;//You can think of the -1 part as changing from 1-based index to 0-based index.
            sb.insert(0, (char)('A' + n%26));
            n = n/26;
        }
       
        
        return sb.toString();
    }
}


171. Excel Sheet Column Number.txt

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
Example 1:

Input: "A"
Output: 1
Example 2:

Input: "AB"
Output: 28
Example 3:

Input: "ZY"
Output: 701

class Solution {
    public int titleToNumber(String s) {
        
        if(s == null || s.length() ==0) return 0;
        
        int level = 0;
        int res = 0;
        
        for(int i = s.length() -1; i >=0 ;i--){
            char c = s.charAt(i);
            res += Math.pow(26,level++)*convert(c);
        }
        
        return res;
        
    }
    
    private int convert(char c){
        return c - 'A' + 1;
    }
}


173. Binary Search Tree Iterator.txt

173. Binary Search Tree Iterator

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

Credits:
Special thanks to @ts for adding this problem and creating all test cases.

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
    
    Stack<TreeNode> stack = new Stack<>();
    
    public BSTIterator(TreeNode root) {
        pushAll(root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
       TreeNode node = stack.pop();
        pushAll(node.right);
        return node.val;
    }
    
    private void pushAll(TreeNode root){
        
        TreeNode currNode = root;
        while(currNode != null){
            stack.push(currNode);
            currNode = currNode.left;
        }
        
    }
    
    
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */

174. Dungeon Game.txt

The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

 

Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.

-2(K)	-3	3
-5	   -10	1
10	   30	  -5 (P)
 

Note:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.

class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        if(dungeon == null || dungeon.length == 0) return 0;
        
        int rows = dungeon.length;
        int cols = dungeon[0].length;
        
        int dp[][] = new int[rows][cols];
        dp[rows-1][cols-1] =  dungeon[rows-1][cols-1] < 0? -dungeon[rows-1][cols-1] : 0;
        
        for(int row = rows -2; row >=0; row--){
            dp[row][cols-1] = dungeon[row][cols-1] - dp[row+1][cols-1] < 0? dp[row+1][cols-1] - dungeon[row][cols-1]:0;              
        }
        
        for(int col = cols -2; col >=0; col--){
            dp[rows-1][col] = dungeon[rows-1][col] - dp[rows-1][col+1] < 0?dp[rows-1][col+1] - dungeon[rows-1][col]:0;              
        }
        
        for(int row = rows -2; row >= 0; row--){
            for(int col = cols -2; col >=0; col--){
                int t1 = dungeon[row][col] - dp[row+1][col] < 0? dp[row+1][col]  - dungeon[row][col]: 0;
                int t2 = dungeon[row][col] - dp[row][col+1] < 0? dp[row][col+1]  - dungeon[row][col]: 0;
                dp[row][col] = Math.min(t1,t2);
            }
        }
        
        return dp[0][0] +1;
        
        
    }
}


186.Reverse Words in a String II.txt

Given an input string , reverse the string word by word. 

Example:

Input:  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]
Note: 

A word is defined as a sequence of non-space characters.
The input string does not contain leading or trailing spaces.
The words are always separated by a single space.
Follow up: Could you do it in-place without allocating extra space?


public class Solution {
    /**
     * @param str: a string
     * @return: return a string
     */
    public char[] reverseWords(char[] str) {
        // write your code here
        // write your code here
        if(str == null || str.length < 2) {
            return str;
        }
        
        int len = str.length;
        reverse(str,0, len -1);
        int left = 0;
        for(int right = 0; right < len; right++){
            if(str[right] == ' '){
                reverse(str,left, right-1);
                left = right+1;
            }
            //straight forward to handle len - 1 case
            if(right == len - 1){
                reverse(str,left, right);
            }
            
        }
        return str;
    }
    
    private void reverse(char strs[], int low, int high){
        while(low < high){
            char temp = strs[low];
            strs[low++] = strs[high];
            strs[high--] = temp;
        }
    }
}

Solution 1: version 2
class Solution {
    public void reverseWords(char[] str) {
        if(str == null || str.length <2){
            return;
        }
        
        int len = str.length;
        reverse(str, 0, len-1);
        
        for(int i = 0, j = 1; j < len && i < len; j++){
            if(str[j] == ' '){
                reverse(str, i, j-1);
                i = j+1;
            }else if(j == len -1){
                reverse(str, i,j);
                break;
            }
        }
        
    }
    
    private void reverse(char[] str, int start, int end){
        int left = start, right = end;
        while(left < right){
            char temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}


189. Rotate Array.txt

Given an array, rotate the array to the right by k steps, where k is non-negative.

Example 1:

Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
Note:

Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
Could you do it in-place with O(1) extra space?

solution 1: new nums
class Solution {
    public void rotate(int[] nums, int k) {
        if( nums == null || nums.length <= 1) return;
        int len = nums.length;
        int K = k%len;
        
        int newNums[] = new int[len];
        int index = 0;
        for(int i = (len-K);i <len; i++){
             newNums[index++] = nums[i];
        }
        
        for(int i = 0; i < (len-K); i++){
            newNums[index++] = nums[i];
        }
        
        for(int i = 0; i < len; i++){
            nums[i] = newNums[i];
        }
        
    }
}

solution 2: reverse
class Solution {
    public void rotate(int[] nums, int k) {
        if(nums == null || nums.length < 2) return;
        int len = nums.length;
        int K= k%len;
        helper(nums, 0, len - K -1);
        helper(nums, len-K, len-1);
        helper(nums, 0, len-1);
    }
    
    private void helper(int[] nums, int low, int high){
        while(low < high){
            int temp = nums[low];
            nums[low++] = nums[high];
            nums[high--] = temp;
        }
    }
}


191. Number of 1 Bits.txt

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Example 1:

Input: 11
Output: 3
Explanation: Integer 11 has binary representation 00000000000000000000000000001011 
Example 2:

Input: 128
Output: 1
Explanation: Integer 128 has binary representation 00000000000000000000000010000000




/**
n = n>>>1;
We need to use bit shifting unsigned operation >>> (while >> depends on sign extension)

We keep doing this until the input Integer is 0.
In Java we need to put attention on the fact that the maximum integer is 2147483647. Integer type in Java is signed and 
there is no unsigned int. So the input 2147483648 is represented in Java as -2147483648 (in java int type has a cyclic representation, 
that means Integer.MAX_VALUE+1==Integer.MIN_VALUE).
This force us to use

n!=0

in the while condition and we cannot use

n>0

because the input 2147483648 would correspond to -2147483648 in java and the code would not enter the while if the condition is n>0 
for n=2147483648.
*/
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        
        while(n != 0){
            count += n&1;
            
            n = n>>>1;
            
        }
        
        return count;
        
    }
}


198. House Robber.txt

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
class Solution {
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        int len = nums.length;
        
        int dp[] = new int[len+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i <=len; i++){
            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1]);
        }
        
        return dp[len];
        
    }
}


200. Number of Islands.txt

200. Number of Islands
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input:
11110
11010
11000
00000

Output: 1
Example 2:

Input:
11000
11000
00100
00011

Output: 3
solution: dfs and reset 1 to 0
class Solution {
    int dirs[][] = {{0,-1},{-1,0},{0,1},{1,0}};
    
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0){
            return 0;
        }
        
        int count = 0;
        int rows = grid.length;
        int cols = grid[0].length;
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                if(grid[row][col] == '1'){
                    count++;
                    dfs(grid, row,col, rows, cols);
                }
                
            }
        }
        return count;
    }
    
    private void dfs(char[][] grid, int row, int col, int rows, int cols){
        if(row <0 || row >= rows || col < 0 || col >= cols || grid[row][col] == '0'){
            return;
        }
        
        grid[row][col] = '0';
        
        for(int dir[]: dirs){
            dfs(grid, row+ dir[0], col + dir[1], rows, cols);
        }
        
    }
}

#solution 2: union find
class Solution {
    
    class UnionFind{
        int parents[];
        
        public UnionFind(int m, int n){
            parents = new int[m*n];
            
            for(int i = 0; i < m ; i++){
                for(int j = 0; j < n; j++){
                    parents[n*i+j] = n*i +j;
                }
            }
        }
        
        public int find(int x){
            if(parents[x] != x){
                parents[x] = find(parents[x]);
            }
            
            return parents[x];
        }
        
        public boolean union(int x, int y){
            int px = find(x);
            int py = find(y);
            
            if(px == py){
                return false;
            }
            
            parents[py] = px;
            return true;
        }
    }
    
    int dirs[][] = {{0,-1},{-1,0},{0,1},{1,0}};
    
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0){
            return 0;
        }
        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;
       
        UnionFind uf = new UnionFind(rows, cols);
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                
                if(grid[row][col] == '1'){
                    count++;
                    for(int dir[]: dirs){
                        int newRow = row + dir[0];
                        int newCol = col + dir[1];
                        if(newRow >= 0 && newRow< rows && newCol>=0 && newCol < cols && grid[newRow][newCol] == '1'){
                            if(uf.union(cols*newRow + newCol,cols*row + col)){
                                count--;
                            }
                        }
                    }
                }
                
            }
        }
        return count;
    }
}



204. Count Primes.txt

Count the number of prime numbers less than a non-negative number, n.

Example:

Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.

class Solution {
    public int countPrimes(int n) {
        boolean isPrime[] = new boolean[n];
        Arrays.fill(isPrime, true);
        
        for(int i = 2; i*i <= n; i++){
            if(isPrime[i] == false){
                continue;
            }
            
            for(int j = 2; (j*i) < n; j++){
                isPrime[j*i] =  false;
            }
        }
        int count = 0;
        for(int i = 2; i < n; i++){
            if(isPrime[i]){
                count++;
            }
        }
        return count;
    }
}

solution 2:
public class Solution {
    /**
     * @param n: a integer
     * @return: return a integer
     */
    public int countPrimes(int n) {
        // write your code here
        int count[] = new int[n];
        //numbers are prime if the only divisors they have are 1 and itself,
        //you really only have to go up to the square root of n, because 
        //if you list out all of the factors of a number, the square root will always be in the middle
        for(int i = 2; i*i < n; i++ ){
            for(int j = 2; i*j< n; j++){
                count[i*j] = -1;
            }
        }
        
        int res = 0;
        for(int i = 2; i < n; i++){
            if(count[i] == 0){
                res++;
            }
        }
        
        return res;
        
    }
}



205. Isomorphic Strings.txt

Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: s = "egg", t = "add"
Output: true
Example 2:

Input: s = "foo", t = "bar"
Output: false
Example 3:

Input: s = "paper", t = "title"
Output: true
Note:
You may assume both s and t have the same length.

solution 1: two hashing arrays
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s == null || s.length() == 0 || t == null || t.length() == 0 ) return true;
        
        Character stMap[] = new Character[256];
        Character tsMap[] = new Character[256];
        char sc[] = s.toCharArray();
        char tc[] = t.toCharArray();
        
        for(int i = 0; i < sc.length; i++){
            
            Character stVal = stMap[sc[i]];
            Character tsVal = tsMap[tc[i]];
            if(stVal == null && tsVal == null){
                stMap[sc[i]] = tc[i];
                tsMap[tc[i]] = sc[i];
            }else if(stVal != null && tsVal != null){
                if(tc[i] != stVal) return false;
            }else{
                return false; 
            }
                        
        }
        
        return true;
    }
}

solution 2: two maps
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s == null || s.length() == 0 || t == null || t.length() == 0 ) return true;
        
        Map<Character,Character> stMap = new HashMap<>();
        Map<Character,Character> tsMap = new HashMap<>();
        char sc[] = s.toCharArray();
        char tc[] = t.toCharArray();
        
        for(int i = 0; i < sc.length; i++){
            
            Character stVal = stMap.get(sc[i]);
            Character tsVal = tsMap.get(tc[i]);
            if(stVal == null && tsVal == null){
                stMap.put(sc[i], tc[i]);
                tsMap.put(tc[i], sc[i]);
            }else if(stVal != null && tsVal != null){
                if(tc[i] != stVal) return false;
            }else{
                return false; 
            }
                        
        }
        
        return true;
    }
}


206. Reverse Linked List.txt

Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

class Solution {
    public ListNode reverseList(ListNode head) {
       
        ListNode prev = null,next = null;
        ListNode curr = head;
        while(curr != null){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}

class Solution {
    public ListNode reverseList(ListNode head) {        
        if(head == null || head.next == null){
            return head;
        }
        
        ListNode reversedList = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        
        return reversedList;
 
    }
}


207. Course Schedule.txt

207. Course Schedule
There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

Example 1:

Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.
Example 2:


Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.
Note:

The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.
 Hints:

This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.
#solution: build graph and dfs

class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> list = new ArrayList<>(numCourses);
        if(prerequisites == null || prerequisites.length == 0 || numCourses == 0){
            return true;
        }
        
        for(int i = 0 ;i < numCourses; i++){
            list.add(new ArrayList<Integer>());
        }
        
        for(int edges[] : prerequisites){
            list.get(edges[0]).add(edges[1]);
        }
        
        int status[] = new int[numCourses];
        for(int i = 0;i<numCourses;i++){
            if(dfs(list, i, status) == false){
                return false;
            }
        }
        
        return true;
        
    }
    
    private boolean dfs(List<List<Integer>> list,  int courseNum, int status[]){
        
        if(status[courseNum] == 1){
            return false;
        }
        if(status[courseNum] == 2){
            return true;
        }
        
        
        status[courseNum] = 1;
        
        for(int node: list.get(courseNum)){
            if(!dfs(list, node, status)){
                return false;
            }    
        }
        status[courseNum] = 2;
        return true;
    }
}

210. Course Schedule II.txt

210. Course Schedule II
There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

Example 1:

Input: 2, [[1,0]] 
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   
             course 0. So the correct course order is [0,1] .
Example 2:

Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. 
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .
Note:

The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.
Hints:

This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.

class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int res[] = new int[numCourses];
        if(numCourses == 0){
            return res;
        }
        
        if( prerequisites ==null || prerequisites.length == 0){
            for(int i= 0; i< numCourses;i++){
                res[i] = i;
            }
            return res;
        }
        
        int status[] = new int[numCourses];
        List<Integer> resList = new ArrayList<>();
        
        List<List<Integer>> list = new ArrayList<>(numCourses);
        
        for(int i = 0; i < numCourses; i++){
            list.add(new ArrayList<Integer>());
        }
        
        for(int edge[]: prerequisites){
            list.get(edge[0]).add(edge[1]);
        }
        
        for(int i = 0; i < numCourses; i++){
            if(!dfs(list, i, status, resList)){
                return new int[0];
            }
        }
        
        for(int i = 0; i < numCourses;i++){
            res[i] = resList.get(i);
        }
        
        return res; 
    }
    
    private boolean dfs( List<List<Integer>> list, int curr, int status[], List<Integer> resList){
        if(status[curr] == 1){
            return false;
        }
        
        if(status[curr] == 2){
            return true;
        }
        
        status[curr] = 1; 
        for(int neibour: list.get(curr)){
            if(!dfs(list, neibour,status, resList)){
                return false;
            }
        }
        
        status[curr] = 2;
        resList.add(curr);
        return true;
        
    }
        
}

212. Word Search II.txt

Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

Example:

Input: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

Output: ["eat","oath"]
Note:
You may assume that all inputs are consist of lowercase letters a-z.
solution 1: version 1:
class Solution {
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    private class Trie{
        Trie children[] = new Trie[26];
        String word;
    }
    Trie root = new Trie();
    private void addWord(String word){
        Trie curr = root;
        for(char c: word.toCharArray()){
            if(curr.children[c-'a'] == null){
                curr.children[c-'a'] = new Trie();
            }
            curr = curr.children[c-'a'];
        }
        curr.word = word;
    }
    
    public List<String> findWords(char[][] board, String[] words) {
        List<String> res = new ArrayList<>();
        if(board == null || board.length == 0 || words == null || words.length ==0 ) return res;
        
        for(String word: words){
            addWord(word);
        }
        
        int rows = board.length;
        int cols = board[0].length;
        
        boolean status[][] = new boolean[rows][cols];
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                dfs(res, board, root, status, row, col);
            }
        }
        
        return res;
        
    }
    
    public void dfs(List<String> res, char[][] board, Trie trie, boolean[][] status, int row, int col){
       
        
        char c = board[row][col];
        if(trie.children[c-'a'] == null) return;
        
        trie = trie.children[c-'a'];
        
        if(trie.word != null){
            res.add(trie.word);
            trie.word = null;
        }
        
        status[row][col] = true;
        for(int dir[]: dirs){
            int newRow = row+dir[0];
            int newCol= col+dir[1];
             if(newRow >=0 && newRow < board.length && newCol >= 0 && newCol < board[0].length && status[newRow][newCol] == false){
                dfs(res, board, trie, status, newRow , newCol);
             }
        }
        status[row][col] = false;
        
    }
}

solution 1: version 2

class Solution {
    int dirs[][] = {{0,-1},{-1,0},{0,1},{1,0}};
    int longestLen = 0;
    public List<String> findWords(char[][] board, String[] words) {
        Set<String> res = new HashSet<>();
        if(board == null || board.length == 0){
            return new ArrayList<String>(res);
        }
        
        TrieNode root = new TrieNode();
        for(String word: words){
            addWordToTrieNode(root, word);
        }
        
        int rows = board.length;
        int cols = board[0].length;
        boolean status[][] = new boolean[rows][cols];
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                dfs(row, col,rows,cols,board, root, res, status); 
            }
        }
        
        return new ArrayList<String>(res);
    }
    
    private void dfs(int row, int col, int rows, int cols, char[][] board, TrieNode node, Set<String> res, boolean status[][]){
               
        if(row < 0 || row >= rows || col <0 || col >= cols || status[row][col]){
            return;
        }
        
        int k = board[row][col] - 'a';
        if(node.children[k] == null){
            return;
        }  
        
        if(node.children[k].word != null){
            res.add(node.children[k].word);
            node.children[k].word = null;
        }
        
        status[row][col] = true;   
        for(int dir[]: dirs){
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            
            dfs(newRow, newCol, rows, cols, board, node.children[k], res, status);
        }

        status[row][col] = false;   
    }
    
    private void addWordToTrieNode(TrieNode root, String word){
        TrieNode p = root;
        for(char c: word.toCharArray()){
            if(p.children[c-'a'] == null){
                p.children[c-'a'] = new TrieNode();
            }
            p = p.children[c-'a'];
        }
        p.word = word;
        
    }
    
    private class TrieNode{
        TrieNode children[] = new TrieNode[26];
        String word;
    }
    
    
}


213. House Robber II.txt

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
Example 2:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.

class Solution {
    
    public int rob(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        
        int len = nums.length;
        
        int dp[] = new int[len+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i <len; i++){
            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1]);
        }
        
        int max1 = dp[len-1];
        
        dp[1] = 0;
        dp[2] = nums[1];
        for(int i = 3; i <=len; i++){
            dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1]);
        }
        
        int max2 = dp[len];
        
        return Math.max(max1,max2);
        
    }
}


215. Kth Largest Element in an Array.txt

215. Kth Largest Element in an Array
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: [3,2,1,5,6,4] and k = 2
Output: 5
Example 2:

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.

solution: quickselect + partition
class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(nums == null || nums.length == 0){
            return -1;
        }
        
       return quickSelect(nums, 0, nums.length-1, nums.length -k);
    }
    
    private int quickSelect(int[] nums, int left, int right, int target){
        int piviot = partition(nums, left, right);
        if(piviot > target){
            return quickSelect(nums, left, piviot-1, target);
        }else if(piviot < target){
            return quickSelect(nums, piviot+1, right, target);
        }else{
            return nums[piviot];
        }
    }
    
    private int partition(int[] nums,int start, int end){
        
        int pivot = end;
        int left = start, right = end-1;
        
        while(left <= right){
            while(left <=right && nums[left]<= nums[pivot]) left++;
            while(left<=right && nums[right] > nums[pivot]) right--;
            if(left <= right){
                swap(nums,left, right);
            }
        }
        swap(nums,left,pivot);
        return left;
    }
    
    private void swap(int nums[], int index1,int index2){
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}

234. Palindrome Linked List.txt

Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1->2
Output: false
Example 2:

Input: 1->2->2->1
Output: true
Follow up:
Could you do it in O(n) time and O(1) space?

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
    // write your code here
      // write your code here
        if(head == null || head.next == null){
            return true;
        }
        
        int len = 0;
        ListNode tempNode = head;
        while(tempNode != null){
            len++;
            tempNode = tempNode.next;
        }
        
        int index = 0;
        Stack<ListNode> stack = new Stack<>();
        
        tempNode = head;
        while(tempNode != null && index < len/2){
            index++;
            stack.push(tempNode);
            tempNode = tempNode.next;
        }
        
        if(len%2 == 1){
            tempNode = tempNode.next;
        }
        
        while(!stack.isEmpty() && tempNode != null){
            if(stack.pop().val != tempNode.val){
                return false;
            }
            tempNode = tempNode.next;
        }
        
        return stack.isEmpty() && tempNode == null; 
    }
    
}


235. Lowest Common Ancestor of a Binary Search Tree.txt

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
Example 1:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Example 2:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself 
             according to the LCA definition.
Note:

All of the nodes' values will be unique.
p and q are different and both values will exist in the BST.


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        
        if(p.val > q.val){
            return lowestCommonAncestor(root, q, p);
        }
        
        int rootVal = root.val;
        if(root ==p || root == q || (rootVal < q.val && rootVal > p.val)){
            return root;
        }else if(rootVal > q.val){
            return lowestCommonAncestor(root.left, p, q);
        }else{
            return lowestCommonAncestor(root.right, p, q);
        }
        
        
    }
}


236. Lowest Common Ancestor of a Binary Tree.txt

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given the following binary search tree:  root = [3,5,1,6,2,0,8,null,null,7,4]

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of of nodes 5 and 1 is 3.
Example 2:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself
             according to the LCA definition.
Note:

All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root != null){
            System.out.println(root.val);
        }
        if(root == null || root == p || root == q){
            return root;
        }
        
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        
        if(left != null && right != null){
            System.out.println("Ok" + root.val);
            return root;
        }
        
        return left == null? right:left;
    }
}


237. Delete Node in a Linked List.txt

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:

    4 -> 5 -> 1 -> 9
Example 1:

Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list
             should become 4 -> 1 -> 9 after calling your function.
Example 2:

Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list
             should become 4 -> 5 -> 9 after calling your function.
Note:

The linked list will have at least two elements.
All of the nodes' values will be unique.
The given node will not be the tail and it will always be a valid node of the linked list.
Do not return anything from your function.

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        
        ListNode nextNode = node.next;
        
        node.val = nextNode.val;
        node.next = nextNode.next;
        
    }
}


238. Product of Array Except Self.txt

238. Product of Array Except Self
Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
#solution 1, Space Complexity O(1)

class Solution {
    public int[] productExceptSelf(int[] nums) {
        if(nums == null || nums.length == 0) return null;
        
        int len = nums.length;
        int res[] = new int[len];
        Arrays.fill(res, 1);
        int rightSide = 1;
        
        for(int i = 1; i < len; i++){
            res[i] =  res[i-1] * nums[i-1];
        }
        
        for(int i= len - 2; i>=0;i--){
            rightSide *= nums[i+1];
            res[i] *= rightSide ;
        }
        
        return res; 
    }
}

#solutin 2: space complexity O(n)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        if(nums == null){
            return null;
        }
        
        int res[] = new int[nums.length]; 
        int leftSides[] = new int[nums.length];
        int rightSides[] = new int[nums.length];
        Arrays.fill(leftSides, 1);
        Arrays.fill(rightSides, 1);
        
        for(int i = 0; i < nums.length; i++){
            if(i == 0){
                leftSides[i] = nums[i];
            }else{
                leftSides[i] = leftSides[i-1] * nums[i];
            }
        }
        
        for(int i = nums.length -1; i >=0; i--){
            if(i == nums.length -1){
                rightSides[i] = nums[i];
            }else{
                rightSides[i] = rightSides[i+1] * nums[i];
            }
        }
        
        for(int i = 0; i < nums.length; i++){
            if(i == 0){
                res[i] = rightSides[i+1];
            }else if(i == nums.length -1){
                res[i] = leftSides[i-1];
            }else{
                res[i] = leftSides[i-1] * rightSides[i+1];
            }
        }
        
        return res;
        
        
    }
}

#solution 3, Space Complexity O(1)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        if(nums == null){
            return null;
        }
        
        int res[] = new int[nums.length]; 
        Arrays.fill(res, 1);
        
        int leftSides = 1;
        int rightSides = 1;
        
        for(int i = 1; i < nums.length; i++){
            res[i] = leftSides * nums[i-1];
            leftSides = res[i];
        }
        
        for(int i = nums.length -2; i >=0; i--){
            res[i] *= rightSides * nums[i+1];
            rightSides = rightSides * nums[i+1];
        }
        
        return res;
        
        
    }
}


239. Sliding Window Maximum.txt

239. Sliding Window Maximum
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

Example:

Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Note: 
You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.

Follow up:
Could you solve it in linear time?

solution: sliding window with deque
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        
        if(nums.length < k){
            return null;
        }
        
        int res[] = new int[nums.length - k + 1];
        int index= 0;
        
        for(int i = 0; i <k; i++){
            while(!deque.isEmpty() && nums[i] > deque.peekLast()){
                deque.removeLast();
            }
            deque.addLast(i);
            
        }
        res[index++] = deque.peekFirst();
        
        for(int i = k ; i< nums.length; i++){
            while(!deque.isEmpty() && nums[i] > deque.peekLast()){
                deque.removeLast();
            }
            
            while(!deque.isEmpty() && deque.peekFirst() <= (i-k)){
                deque.removeFirst();
            }
            
            deque.addLast(i);
            res[index++] = nums[deque.peekFirst()];
        }
        
        return res;
    }
}


252. Meeting Rooms.txt

252. Meeting Rooms
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.

Example 1:

Input: [[0,30],[5,10],[15,20]]
Output: false
Example 2:

Input: [[7,10],[2,4]]
Output: true

solution: sort start and get max end and compare with the new start

/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public boolean canAttendMeetings(Interval[] intervals) {
        if(intervals == null || intervals.length == 0){
            return true;
        }
        
        Comparator<Interval> comparator = new Comparator<Interval>(){
            @Override
            public int compare(Interval i1, Interval i2){
                return i1.start - i2.start;
            }
        };
        
        Arrays.sort(intervals, comparator);
        
        int end = intervals[0].end;
        for(int i = 1; i < intervals.length;i++){
            if(intervals[i].start < end){
                return false;
            }
            end = Math.max(end, intervals[i].end);
        }
        
        return true;
        
    }
}

253 Meeting Rooms II.txt

253 Meeting Rooms II
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.

Example 1:

Input: [[0, 30],[5, 10],[15, 20]]
Output: 2
Example 2:

Input: [[7,10],[2,4]]
Output: 1

solution: sort, priorityqueue, need to update the queue each step
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
class Solution {
    public int minMeetingRooms(Interval[] intervals) {
        if(intervals == null || intervals.length == 0){
            return 0;
        }
        
        Comparator<Interval> comparator = new Comparator<Interval>(){
            @Override
            public int compare(Interval i1, Interval i2){
                return i1.start - i2.start;
            }
        };
        
        Arrays.sort(intervals, comparator);
        
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        
        
        pq.add(intervals[0].end);
        
        for(int i = 1; i < intervals.length; i++){
            if(intervals[i].start >= pq.peek()){
                pq.remove();
            }
            pq.add(intervals[i].end);
            
        }
        
        return pq.size();
        
        
    }
}

258. Add Digits.txt

Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.

Example:

Input: 38
Output: 2 
Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. 
             Since 2 has only one digit, return it.
Follow up:
Could you do it without any loop/recursion in O(1) runtime?

class Solution {
    public int addDigits(int num) {
        int res = num;
        while(res >= 10){
            res = 0;
            while(num > 0){
                res += num%10;
                num = num/10;
            }
            
            if(res >=10){
                num = res;
            }
        }
        
        return res;
    }
}

solution 2:
/**
I'll try to explain the math behind this:
First you should understand:
10^k % 9 = 1
a*10^k % 9 = a % 9 
Then let's use an example to help explain.
Say a number x = 23456
x = 2* 10000 + 3 * 1000 + 4 * 100 + 5 * 10 + 6
2 * 10000 % 9 = 2 % 9
3 * 1000 % 9 = 3 % 9
4 * 100 % 9 = 4 % 9
5 * 10 % 9 = 5 % 9
Then x % 9 = ( 2+ 3 + 4 + 5 + 6) % 9, note that x = 2* 10000 + 3 * 1000 + 4 * 100 + 5 * 10 + 6
So we have 23456 % 9 = (2 + 3 + 4 + 5 + 6) % 9
**/
class Solution {
    public int addDigits(int num) {
        if(num == 0) return 0;
        if(num %9 == 0) return 9;
        return num%9;
    }
}


261. Graph Valid Tree.txt

261. Graph Valid Tree
Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

Example 1:

Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]
Output: true
Example 2:

Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]
Output: false
Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.

Solution 1: dfs
class Solution {
    public boolean validTree(int n, int[][] edges) {
        
        if(edges == null){
            return true;
        }
        
        if((n - 1) != edges.length){
            return false;
        }
        
        Map<Integer,List<Integer>> map = new HashMap<>();
        for(int i = 0; i< n; i++){
            map.put(i, new ArrayList<Integer>());
        }
        
        for(int edge[]: edges){
            map.get(edge[0]).add(edge[1]);
            map.get(edge[1]).add(edge[0]);
        }
        
        return dfs(map,n) ;
        
    }
    
    private boolean dfs(Map<Integer,List<Integer>> map, int n){
        int status[] = new int[n];
        Arrays.fill(status, 0);
        
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        status[0] = 1;
        while(!stack.isEmpty()){
            int curr = stack.pop();
            List<Integer> currList = map.get(curr);
            for(Integer child: currList){
                if(status[child] == 0){
                    stack.push(child);
                    status[child] = 1;
                }else if(status[child] == 1){
                    return false;
                }
                
            }
            
            status[curr] = 2;
            
        }
        
        for(int s: status){
            if(s == 0){
                return false;
            }
        }
        
        return true;
    
        
    }
}

#solution 2: Union Find
class Solution {
    
    class UnionFind{
        int parents[];
        
        public UnionFind(int n){
            parents = new int[n];
            for(int i = 0; i < n; i++){
                parents[i] = i;
            }
        }
        
        public int find(int u){
            if(u != parents[u]){
                parents[u] = find(parents[u]);
            }
            
            return parents[u];
        }
        
        public boolean union(int u, int v){
            int pu = find(u);
            int pv = find(v);
            if (pu == pv){
                return false;
            }
            
            parents[pv] = pu;
            return true;
        }
        
    }
    public boolean validTree(int n, int[][] edges) {
        
        if(edges == null || n -1 != edges.length ){
            return false;
        }
        
        UnionFind uf = new UnionFind(n);
        for(int edge[]: edges){
            if(!uf.union(edge[0],edge[1])){
                return false;            
            }
            
        }
        
        return true;
        
    }
    
   
}


269. Alien Dictionary.txt

269. Alien Dictionary
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

Example 1:

Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"
Example 2:

Input:
[
  "z",
  "x"
]

Output: "zx"
Example 3:

Input:
[
  "z",
  "x",
  "z"
] 

Output: "" 

Explanation: The order is invalid, so return "".
Note:

You may assume all letters are in lowercase.
You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.

solution: topological & dfs
class Solution {
    int status[] = new int[26];  
    public String alienOrder(String[] words) {
        Map<Character, Set<Character>> map = new HashMap<>();
        for(char c='a'; c<='z';c++){
            map.put(c, new HashSet<Character>());
        }
        
       
        String prevWord = words[0], currWord;
        for(int i = 1; i < words.length; i++){
            currWord = words[i];
            
            int j = 0;
            int prevLen = prevWord.length();
            int currLen = currWord.length();
            boolean isTheSame = true;
            while(j < prevLen && j < currLen){
                if(prevWord.charAt(j) != currWord.charAt(j)){
                    map.get(prevWord.charAt(j)).add(currWord.charAt(j));
                    isTheSame = false;
                    break;
                }else{
                    j++;
                }
            }
            
            if(isTheSame && prevLen > currLen){
                 return "";
            }
            
            prevWord = currWord;
        }
        
        StringBuilder sb = new StringBuilder();
         for(Character c: map.keySet()){
            if(map.get(c).size() == 0){
                continue;
            }
            if(dfs(sb,map,c) == false){
                return "";
            } 
         }
        
        return sb.reverse().toString();
    }
    
    private boolean dfs(StringBuilder sb,  Map<Character, Set<Character>> map, Character c){
        
        if(status[c-'a'] == 1){
            return false;
        }
        
        if(status[c-'a'] == 2){
            return true;
        }
        
        status[c-'a'] = 1;
        
        
        for(Character node: map.get(c)){
            if(dfs(sb,map,node) == false){
                return false;
            }
        }
            
        status[c -'a'] = 2;
        sb.append(c);
        return true;
    }
}

270. Closest Binary Search Tree Value.txt

270. Closest Binary Search Tree Value
Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.

Note:

Given target value is a floating point.
You are guaranteed to have only one unique value in the BST that is closest to the target.
Example:

Input: root = [4,2,5,1,3], target = 3.714286

    4
   / \
  2   5
 / \
1   3

Output: 4

solution: bst
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int closestValue(TreeNode root, double target) {
        double diff = Double.MAX_VALUE;
        Integer res = null; 
        
        TreeNode curr = root;
        
        while(curr != null){
            if(diff > Math.abs(target - curr.val)){
                res = curr.val;
                diff = Math.abs(target - curr.val);
            }
            if(target > curr.val){
                curr = curr.right;
            }else{
                curr = curr.left;
            }
        }
        
        return res;
    }
}

Solution: DFS - not using the bst feature
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param root: the given BST
     * @param target: the given target
     * @return: the value in the BST that is closest to the target
     */
    public int closestValue(TreeNode root, double target) {
        // write your code here
        double diff = Math.abs(target - root.val);
        int res = root.val;
        
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        
        while(!stack.isEmpty()){
            TreeNode curr = stack.pop();
            
            if(diff > Math.abs(curr.val - target)){
                diff = Math.abs(curr.val - target);
                res = curr.val;
            }
            
            if(curr.left != null) stack.push(curr.left);
            if(curr.right !=null) stack.push(curr.right);
        }
        
        return res;
        
    }
}


273. Integer to English Words.txt

273. Integer to English Words
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.

Example 1:

Input: 123
Output: "One Hundred Twenty Three"
Example 2:

Input: 12345
Output: "Twelve Thousand Three Hundred Forty Five"
Example 3:

Input: 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
Example 4:

Input: 1234567891
Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"

class Solution {
    private final String[] LESS_THAN_20 = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    private final String[] TENS = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    private final String[] THOUSANDS = {"", "Thousand", "Million", "Billion"};
    public String numberToWords(int num) {
        if(num == 0){
            return "Zero";
        }
        
        int index = 0;
        String res="";
        
        while(num > 0){
            if(num%1000 != 0){
                res = helper(num%1000) + THOUSANDS[index] + " " + res;
            }
            
            num /=1000;
            index++;
        }
        
        return res;
        
    }
    
    private String helper(int num){
        if(num == 0){
            return "";
        }
        if(num < 20){
            return LESS_THAN_20[num] + " ";
        }
        if(num < 100){
            return TENS[num/10] + " " + helper(num%10);
        }
        
        if(num < 1000){
            return LESS_THAN_20[num/100] + " Hundred" + " " + helper(num%100);
        }
        
        return "";
        
    }
}

277. Find the Celebrity.txt

277. Find the Celebrity

Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.

Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

solution: check knows and not known(cerebrity shouldn't know any people and should known by all)
/* The knows API is defined in the parent class Relation.
      boolean knows(int a, int b); */

public class Solution extends Relation {
    public int findCelebrity(int n) {
      int res = 0;  
      for(int i = 1; i < n; i++){
          if(knows(res, i)){
              res = i;
          }
      }
      
      for(int i = 0; i<n;i++){
          if(i != res && (!knows(i,res)|| knows(res,i))){
              return -1;
          }
          
      }  
        
      return res;  
    }
}


285.Inorder Successor in BST.txt

Inorder Successor in BST
Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

Note: If the given node has no in-order successor in the tree, return null.

Example 1:

Input: root = [2,1,3], p = 1

  2
 / \
1   3

Output: 2
Example 2:

Input: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

Output: null

solution 1: iteration
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if(root == null || p== null){
            return null;
        }
        
        boolean isNextNodeSuccessor = false;
        TreeNode curr = root;
        Stack<TreeNode> stack = new Stack<>();
        
        
        while(!stack.isEmpty() || curr != null){
            
            while(curr != null){
                stack.push(curr);
                curr = curr.left;
            }
            
            curr = stack.pop();
            if(isNextNodeSuccessor){
                return curr;
            }
            
            if(curr == p){
                isNextNodeSuccessor = true;
            }
            
            curr = curr.right;
        }
        
        return null;
        
    }
}

solution 2: improved version
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {

    public TreeNode inorderSuccessor(TreeNode root, TreeNode p){
        if(root == null || p == null){
            return null;
        }
        
        TreeNode res = null;
        
        while(root != null){
            if(root.val > p.val){
                res = root;
                root = root.left;
            }else{
                root = root.right;
            }
            
        }
        
        return res;
    }

    
}

287. Find the Duplicate Number.txt

287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Example 1:

Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
Note:

You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.

class Solution {
    public int findDuplicate(int[] nums) {
        if(nums == null || nums.length == 1){
            return 0;
        }
        
        int l = 1, h=nums.length, n = nums.length, mid;
        int count;
        
        while(l < h){
            count = 0;
            mid = l + (h - l)/2;
            
            for(int num: nums){
                if(num <= mid){
                    count++;
                }
            }
            
            if(count >mid ){
                h = mid;
            }else{
                l = mid+1;
            }
        }
        
        return l;
        
    }
}

295. Find Median from Data Stream.txt

Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

For example,
[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.
Example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
class MedianFinder {


    PriorityQueue<Integer> lHeap = new PriorityQueue<Integer>(Collections.reverseOrder());
    PriorityQueue<Integer> rHeap = new PriorityQueue<Integer>();
    
   
    /** initialize your data structure here. */
    public MedianFinder() {
        
    }
    
    public void addNum(int num) {
        if(lHeap.isEmpty() || num <=lHeap.peek()){
            lHeap.add(num);
        }else{
            rHeap.add(num);
        }
        
        if(lHeap.size() <  rHeap.size()){
            lHeap.add(rHeap.remove());
        }else if ( lHeap.size() - rHeap.size() == 2){
            rHeap.add(lHeap.remove());
        }
      
    }
    
    public double findMedian() {
        if(lHeap.size()> rHeap.size()){
            return (double)lHeap.peek();
        }else{
            return (double)(lHeap.peek() +rHeap.peek())/2;
        }
    }   
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */

297. Serialize and Deserialize Binary Tree.txt

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example: 

You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder res = new StringBuilder();
        //res.append('[');
        if(root == null){
            return null;
        }    
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode currNode = stack.pop();
            if(currNode != null){
                res.append(currNode.val);
                stack.push(currNode.right);
                stack.push(currNode.left);
            }else{
                res.append('#');
            }
            res.append(",");
        }
            
        res.deleteCharAt(res.length()-1);
        //res.append(']'); 
        return res.toString();
    }
    

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //System.out.println("data is:" + data);
        if(data == null){
            return null;
        }
        String nodesStr[] = data.split("\\,");
        Queue<String> queue = new LinkedList<>();
        
        for(String str: nodesStr){
            queue.add(str);
        }
        
        return buildNodes(queue);
        
    }
        
    private TreeNode buildNodes(Queue<String> queue){
            String strVal = queue.remove();
            if("#".equals(strVal)){
                return null;
            }else{
                TreeNode parent = new TreeNode(Integer.valueOf(strVal));
                parent.left = buildNodes(queue);
                parent.right = buildNodes(queue);
                return parent;
            }
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));


300. Longest Increasing Subsequence.txt

Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:

Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?
solution 1: dp - version 1:

class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        
        int len = nums.length;
        int dp[] = new int[len];
        Arrays.fill(dp,1);
        
        for(int i = 1; i <len; i++){
            for(int j = 0; j<i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        int res = Integer.MIN_VALUE;
        for(int count: dp){
            res = Math.max(res, count);
        }
        return res;
        
    }
}

solution 1: dp
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums == null) return 0;
        
        if( nums.length < 2) return nums.length;
        int len = nums.length;
        int dp[] = new int[len];
        dp[0] = 1;
        int maxRes = 0;
        
        for(int i = 1; i< len; i++){
            int maxVal = 0;
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    maxVal = Math.max(maxVal, dp[j]);
                }
            }
            
            dp[i] = Math.max(maxVal + 1,dp[i]);
            maxRes = Math.max(dp[i], maxRes);
        }
        
        
        return maxRes;
    }
}

solution 2: time limit exceeding
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums == null) return 0;
        if( nums.length < 2) return nums.length;
       
        return helper(nums, Integer.MIN_VALUE, 0);
    }
    
    private int helper(int[] nums, int prev, int currPos){
        if(currPos == nums.length) return 0;
        int taken = 0, notTaken = 0;
        
        if(nums[currPos] > prev){
            taken = 1 + helper(nums, nums[currPos], currPos+1);
        }
        
        notTaken = helper(nums, prev, currPos+1);
        return Math.max(taken, notTaken);
        
    }
}


305. Number of Islands II.txt

305. Number of Islands II
A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example:

Input: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]]
Output: [1,1,2,3]
Explanation:

Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).

0 0 0
0 0 0
0 0 0
Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.

1 0 0
0 0 0   Number of islands = 1
0 0 0
Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.

1 1 0
0 0 0   Number of islands = 1
0 0 0
Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.

1 1 0
0 0 1   Number of islands = 2
0 0 0
Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.

1 1 0
0 0 1   Number of islands = 3
0 1 0
Follow up:

Can you do it in time complexity O(k log mn), where k is the length of the positions?
solution: union find
class Solution {
    int dirs[][] = {{0,-1},{-1,0},{0,1},{1,0}};
    class UnionFind{
        int parents[];
        
        public UnionFind(int m, int n){
            parents = new int[m*n];
            for(int i = 0; i < m*n;i++){
                parents[i] = i;
            }
        }
        
        public int find(int u){
            if(u != parents[u]){
                parents[u] = find(parents[u]);
            }
            return parents[u];
        }
        
        public boolean union(int u, int v){
            int pu = find(u);
            int pv = find(v);
            
            if(pu == pv){
                return false;
            }
            
            parents[pv] = pu;
            return true;
        }
    }
    
    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        int count = 0;
        List<Integer> res = new ArrayList<>();
        UnionFind uf = new UnionFind(m,n);
        int grid[][] = new int[m][n];
        
        if(positions == null || positions.length == 0){
            return res;
        }
        
        for(int p[]:positions){         
            grid[p[0]][p[1]] = 1;
           int curr = n*p[0] + p[1]; 

            count++;
            for(int dir[]:dirs){
                int newRow = p[0] + dir[0];
                int newCol = p[1] + dir[1];
                if(newRow >= 0 && newRow < m && newCol >= 0 && newCol<n && grid[newRow][newCol] ==1){
                    if(uf.union(n*newRow+newCol, curr)){
                        count--;
                    }

                }
            }
               
               res.add(count); 
        }
       
        return res;

    }
}


314. Binary Tree Vertical Order Traversal.txt

314. Binary Tree Vertical Order Traversal

Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from left to right.

Examples 1:

Input: [3,9,20,null,null,15,7]

   3
  /\
 /  \
 9  20
    /\
   /  \
  15   7 

Output:

[
  [9],
  [3,15],
  [20],
  [7]
]
Examples 2:

Input: [3,9,8,4,0,1,7]

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7 

Output:

[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]
Examples 3:

Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2

Output:

[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]

solution: using two queues
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private int min = Integer.MAX_VALUE;
    private int max = Integer.MIN_VALUE;
    
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        
        Map<Integer, List<Integer>> map = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        Queue<Integer> cq = new LinkedList<>();
        
        
        queue.add(root);
        cq.add(0);
        
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.remove();
                int col = cq.remove();
                handleMap(map, col, curr.val);
                
                if(curr.left != null){
                    queue.add(curr.left);
                    cq.add(col-1);
                }
                
                if(curr.right != null){
                    queue.add(curr.right);
                    cq.add(col+1);
                }
            }
            
        }
        
        for(int i = min; i <= max; i++){
            res.add(map.get(i));
        }
        
        return res;
    }
    
    private void handleMap(Map<Integer, List<Integer>> map, int col, int nodeVal){
        if(map.containsKey(col)){
            map.get(col).add(nodeVal);
        }else{
            List<Integer> list = new ArrayList<>();
            list.add(nodeVal);
            map.put(col, list);
        }
        
        min = Math.min(min, col);
        max = Math.max(max, col);
    }
}

322. Coin Change.txt

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Note:
You may assume that you have an infinite number of each kind of coin.


class Solution {
    public int coinChange(int[] coins, int amount) {
        if(coins == null || coins.length==0){
            if(amount == 0){
                return 1;
            }
        }
        int solution[]= new int[amount+1];
        Arrays.fill(solution, Integer.MAX_VALUE);
        solution[0] = 0;// to make 0, need 0 coin
        for(int i = 1; i < amount+1;i++){
                for(int j = 0; j < coins.length; j++){
                    if ( i >= coins[j] && solution[i-coins[j]] != Integer.MAX_VALUE){
                        solution[i] = Math.min(solution[i],1 + solution[i-coins[j] ]);
                    }
                }
            
        }
        
        return solution[amount] == Integer.MAX_VALUE?-1: solution[amount];
    }
}


325. Maximum Size Subarray Sum Equals k.txt

325. Maximum Size Subarray Sum Equals k
Amazon
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest)

Follow Up:
Can you do it in O(n) time?

#solution 1:
Time Complexity: O(n)
Space : O(n)
class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        int sums[] = new int[nums.length];
        map.put(0,-1);
        int max = 0;
        
        for(int i = 0; i< nums.length; i++){
            if(i == 0){
                sums[0] = nums[i];
            }else{
                sums[i] = sums[i-1] + nums[i]; 
            }
            
            if(!map.containsKey(sums[i])){
                map.put(sums[i], i);
            }
            
            if( map.containsKey(sums[i]-k)){
                int pos = map.get(sums[i]-k);
                max = Math.max(max, i - pos);
            }
        }
        
        return max;
    }
}

#solution 2: reuse nums array

class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,-1);
        int max = 0;
        
        for(int i = 0; i< nums.length; i++){
            if(i == 0){
                nums[i] = nums[0];
            }else{
                nums[i] = nums[i-1] + nums[i]; 
            }
            
            if(!map.containsKey(nums[i])){
                map.put(nums[i], i);
            }
            
            if( map.containsKey(nums[i]-k)){
                int pos = map.get(nums[i]-k);
                max = Math.max(max, i - pos);
            }
        }
        
        return max;
    }
}

344.ReverseString.txt

/**
344. Reverse String
Write a function that takes a string as input and returns the string reversed.

Example:
Given s = "hello", return "olleh".

focus: remember to left++ and right-- to avoid infinite loop;
**/


class Solution {
    public String reverseString(String s) {
        if(s == null || s.length() < 2){
            return s;
        }
        
        char chars[]= s.toCharArray();
        int left = 0, right = s.length()-1;
        while(left < right){
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
        
        return new String(chars); 
    }
}

346. Moving Average from Data Stream.txt

Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

For example,

MovingAverage m = new MovingAverage(3);
m.next(1) = 1
m.next(10) = (1 + 10) / 2
m.next(3) = (1 + 10 + 3) / 3
m.next(5) = (10 + 3 + 5) / 3

class MovingAverage {
    ArrayDeque<Integer> deque = new ArrayDeque<>();
    int window[];
    int size;
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        window = new int[size];
        this.size = size;
    }
    
    public double next(int val) {
        if(deque.size() >= size){
            deque.removeFirst();
        }
        deque.addLast(val);
        double sum= 0;
        for(int num: deque){
            sum += num;
        }
        return sum/deque.size();
    }
}

/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage obj = new MovingAverage(size);
 * double param_1 = obj.next(val);
 */

347. Top K Frequent Elements.txt

Given a non-empty array of integers, return the k most frequent elements.

For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].

Note: 
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.

idea:
use two hashmaps and get the max and min count to solve it.

class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        List<Integer> res = new ArrayList<>();
        if(nums == null || nums.length == 0){
            return res;
        }
        
        Map<Integer,Integer> map = new HashMap<>();
        
        for(int num: nums){
            if(!map.containsKey(num)){
                map.put(num,1);    
            }else{
                map.put(num,map.get(num)+1);
            }
        }
        
        Integer min= Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(Map.Entry<Integer,Integer> entry: map.entrySet()){
            min = Math.min(min,entry.getValue());
            max = Math.max(max, entry.getValue());
        }
        
        Map<Integer,List<Integer>> bucket = new HashMap<>();
        
        for(Map.Entry<Integer,Integer> entry: map.entrySet()){
            int num = entry.getKey();
            int times = entry.getValue();
            if(!bucket.containsKey(times)){
                bucket.put(times, new ArrayList<Integer>());
            }
            bucket.get(times).add(num);
        }
        
        for(int i = max; i>=min;i--){
            List<Integer> numList = bucket.get(i);
            if(numList == null){
                continue;
            }
            for(Integer num: numList){
                if(res.size() <k){
                    res.add(num);
                }
            }
        }
    
        return res;
    }
}


348. Design Tic-Tac-Toe.txt

Design a Tic-tac-toe game that is played between two players on a n x n grid.

You may assume the following rules:

A move is guaranteed to be valid and is placed on an empty block.
Once a winning condition is reached, no more moves is allowed.
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.
Example:
Given n = 3, assume that player 1 is "X" and player 2 is "O" in the board.

TicTacToe toe = new TicTacToe(3);

toe.move(0, 0, 1); -> Returns 0 (no one wins)
|X| | |
| | | | // Player 1 makes a move at (0, 0).
| | | |

toe.move(0, 2, 2); -> Returns 0 (no one wins)
|X| |O|
| | | | // Player 2 makes a move at (0, 2).
| | | |

toe.move(2, 2, 1); -> Returns 0 (no one wins)
|X| |O|
| | | | // Player 1 makes a move at (2, 2).
| | |X|

toe.move(1, 1, 2); -> Returns 0 (no one wins)
|X| |O|
| |O| | // Player 2 makes a move at (1, 1).
| | |X|

toe.move(2, 0, 1); -> Returns 0 (no one wins)
|X| |O|
| |O| | // Player 1 makes a move at (2, 0).
|X| |X|

toe.move(1, 0, 2); -> Returns 0 (no one wins)
|X| |O|
|O|O| | // Player 2 makes a move at (1, 0).
|X| |X|

toe.move(2, 1, 1); -> Returns 1 (player 1 wins)
|X| |O|
|O|O| | // Player 1 makes a move at (2, 1).
|X|X|X|
Follow up:
Could you do better than O(n2) per move() operation?

Hint:

Could you trade extra space such that move() operation can be done in O(1)?
You need two arrays: int rows[n], int cols[n], plus two variables: diagonal, anti_diagonal.

class TicTacToe {
    int rows[], cols[], diagonals, antiDiagonals;
    int size;
    /** Initialize your data structure here. */
    public TicTacToe(int n) {
        size = n;
        rows = new int[n];
        cols = new int[n];
    }
    
    /** Player {player} makes a move at ({row}, {col}).
        @param row The row of the board.
        @param col The column of the board.
        @param player The player, can be either 1 or 2.
        @return The current winning condition, can be either:
                0: No one wins.
                1: Player 1 wins.
                2: Player 2 wins. */
    public int move(int row, int col, int player) {
        int toAdd = player == 1? 1: -1;
        
        rows[row] +=toAdd;
        cols[col] +=toAdd;
        
        if(row == col){
            diagonals += toAdd;
        }
        
        if(row == (size - col - 1)){
            antiDiagonals += toAdd;
        }
        
        if(Math.abs(rows[row]) == size || Math.abs(cols[col]) == size || Math.abs(diagonals) == size || Math.abs(antiDiagonals) == size){
            return player;
        }
        
        return 0;
    }
}

/**
 * Your TicTacToe object will be instantiated and called as such:
 * TicTacToe obj = new TicTacToe(n);
 * int param_1 = obj.move(row,col,player);
 */
 
 solution 2:
 class TicTacToe {
    int[][] board;
    int size;
    Player players[];

    class Player{
        int id;
        int[][] pos;
        public Player(int id, int n){
            this.id = id;
            pos = new int[n][n];
        }
        
        public boolean hasWon(){
            boolean won = true;
            for(int row = 0; row < size;row++){
                won = true;
                for( int col = 0; col < size; col++){
                    if(pos[row][col] == 0){
                        won = false;
                        break;
                    }
                }
                if(won == true){
                    return true;
                }
            }
            
            for(int col = 0; col < size;col++){
                won = true;
                for(int row = 0; row < size; row++){
                    if(pos[row][col] == 0){
                        won = false;
                        break;
                    }
                }
                if(won == true){
                    return true;
                }
            }
            
            
            won = true;
            for(int row = 0, col = row;row<size && col<size;row++,col++){
                if(pos[row][col] == 0){
                        won = false;
                        break;
                }
            }
            
            if(won == true){
                    return true;
            }
            
            won = true;
            for(int row = size-1, col = 0; row>=0 && col<size; row--,col++){
                if(pos[row][col] == 0){
                        won = false;
                        break;
                }
            }
            
             if(won == true){
                    return true;
            }
            return false;
        }
        
    }
    
    
    /** Initialize your data structure here. */
    public TicTacToe(int n) {
        this.board = new int[n][n];
        this.size = n;
        this.players = new Player[2];
        this.players[0] = new Player(1,n);
        this.players[1] = new Player(2,n);
    }
    
    /** Player {player} makes a move at ({row}, {col}).
        @param row The row of the board.
        @param col The column of the board.
        @param player The player, can be either 1 or 2.
        @return The current winning condition, can be either:
                0: No one wins.
                1: Player 1 wins.
                2: Player 2 wins. */
    public int move(int row, int col, int player) {
        if(board[row][col] == 1){
            return 0;
        }else{
            Player curr = players[player-1];
            curr.pos[row][col] = 1;
            if(curr.hasWon()){
                return player;
            }else{
                return 0;
            }
            
        }
    }
    
   
}

/**
 * Your TicTacToe object will be instantiated and called as such:
 * TicTacToe obj = new TicTacToe(n);
 * int param_1 = obj.move(row,col,player);
 */


362. Design Hit Counter.txt

Design a hit counter which counts the number of hits received in the past 5 minutes.

Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.

class HitCounter {

    ArrayDeque<Integer> deque = new ArrayDeque<>();
    /** Initialize your data structure here. */
    public HitCounter() {
        
    }
    
    /** Record a hit.
        @param timestamp - The current timestamp (in seconds granularity). */
    public void hit(int timestamp) {
        while(!deque.isEmpty() && timestamp - deque.peekFirst()>= 300){
            deque.removeFirst();
        }
        deque.addLast(timestamp);
    }
    
    /** Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity). */
    public int getHits(int timestamp) {
        
        while(!deque.isEmpty() && timestamp - deque.peekFirst()>= 300){
            deque.removeFirst();
        }
        
        return deque.size();
    }
}

/**
 * Your HitCounter object will be instantiated and called as such:
 * HitCounter obj = new HitCounter();
 * obj.hit(timestamp);
 * int param_2 = obj.getHits(timestamp);
 */

365. Water and Jug Problem.txt

You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.

If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.

Operations allowed:

Fill any of the jugs completely with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.
Example 1: (From the famous "Die Hard" example)

Input: x = 3, y = 5, z = 4
Output: True
Example 2:

Input: x = 2, y = 6, z = 5
Output: False
Credits:
Special thanks to @vinod23 for adding this problem and creating all test cases.

/**
http://www.cnblogs.com/grandyang/p/5628836.html
这是一道脑筋急转弯题，我想很多人以前应该听过这道题目，有一个容量为3升和一个容量为5升的水罐，问我们如何准确的称出4升的水。我想很多人都知道怎么做，先把5升水罐装满水，倒到3升水罐里，这时5升水罐里还有2升水，然后把3升水罐里的水都倒掉，把5升水罐中的2升水倒入3升水罐中，这时候把5升水罐解满，然后往此时有2升水的3升水罐里倒水，这样5升水罐倒出1升后还剩4升即为所求。这个很多人都知道，但是这道题随意给我们了三个参数，问有没有解法，这就比较难了。这里我就照搬网上大神的讲解吧：

这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为x和y，问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么我们可以用一个公式来表达：

z = m * x + n * y

其中m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即3升的水罐往外倒了两次水，5升水罐往里舀了两次水。那么问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立。根据裴蜀定理，ax + by = d的解为 d = gcd(x, y)，那么我们只要只要z % d == 0，上面的等式就有解，所以问题就迎刃而解了，我们只要看z是不是x和y的最大公约数的倍数就行了，别忘了还有个限制条件x + y >= z，因为x和y不可能称出比它们之和还多的水，参见代码如下；
*/
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        if(z < 0 || x + y < z){
            return false;
        }
        
        if(x == z || y == z || x + y == z){
            return true;
        }
        
        //to make sure x >= y
        if(x < y){
            return canMeasureWater(y, x, z);
        }
        
        return z % gcd(x, y) == 0;
    }
    
    public int gcd(int x, int y){
        while(y!= 0){
            int temp = y;
            y = x%y;
            x = temp;
        }
        
        return x;
    }
}

380. Insert Delete GetRandom O(1).txt

Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
Example:

// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();

class RandomizedSet {

    Map<Integer,Integer> map = new HashMap<>();
    List<Integer> list = new ArrayList<>();
    /** Initialize your data structure here. */
    public RandomizedSet() {
        
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }
        
        map.put(val, list.size());
        list.add(val);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }
        
        int last = list.get(list.size() -1 );
        int posOfLast = map.get(last);
        int posOfVal = map.get(val);
        
        if(last != val){
            map.put(last, posOfVal);
            list.set(posOfVal, last);
        }
        
        list.remove(list.size()-1);
        map.remove(val);
        
        
        return true;
        
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        Random random = new Random();
        return list.get(random.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */


387.First_Unique_Character_in_a_String.txt

/**387. First Unique Character in a String
Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

Examples:

s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
Note: You may assume the string contain only lowercase letters.
*/

//solution 1: map to store the position of each characters
// time complexicity: O(n) 
//space complexity: O(n)
class Solution {
    public int firstUniqChar(String s) {
        
        if(s == null || s.length() == 0){
            return -1;
        }
        
        //key: letter, val: pos( if -1: repeated)
        Map<Character, Integer> map = new HashMap<>();
        Integer min = null;
        
        
        for(int i = 0 ; i< s.length(); i++){
            Character c = s.charAt(i);
            if(map.containsKey(c)){
                map.put(c, -1);
            }else{
                map.put(c, i);
            }
        }
        
        for(Character c: map.keySet()){
            int pos = map.get(c);
            if(pos == -1){
                continue;
            }else{
                if(min == null){
                    min = pos;
                }else{
                    min = Math.min(min, pos);
                }
            }
        }
        
        if(min == null){
            min = -1;
        }
        
        return min;
        
    }
}

//solution 2, using int characters table to store the count of each characters(lower case in this question)
// time complexicity: O(n) 
//space complexity: O(1)
class Solution {
    public int firstUniqChar(String s) {
        if(s == null || s.length() == 0){
            return -1;
        }
        int letters[] = new int[26];
        
        for(char c: s.toCharArray()){
            letters[c-'a']++;
        }
        
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(letters[c-'a'] == 1){
                return i;
            }
        }
        
        return -1;
    }
}



408.Valid Word Abbreviation.txt

Description
Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.

A string such as "word" contains only the following valid abbreviations:

["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
Notice that only the above abbreviations are valid abbreviations of the string word. Any other string is not a valid abbreviation of word.

Example
Example 1:

Given s = "internationalization", abbr = "i12iz4n":
Return true.
Example 2:

Given s = "apple", abbr = "a2e":
Return false.

public class Solution {
    /**
     * @param word: a non-empty string
     * @param abbr: an abbreviation
     * @return: true if string matches with the given abbr or false
     */
    public boolean validWordAbbreviation(String word, String abbr) {
        // write your code here
       
        char s[] = word.toCharArray();
        char t[] = abbr.toCharArray();
        int i = 0, j = 0, sLen = s.length, tLen = t.length;
        
        while(i < sLen && j < tLen){
            if(Character.isDigit(t[j])){
                if(t[j] == '0') return false;
                int val = 0;
                while(j < tLen && Character.isDigit(t[j])){
                    val = val*10 + (t[j] - '0');
                    j++;
                }
                
                i += val;
                
            }else{
                if(s[i++] != t[j++]) return false;
            }

            
        }
       
       return i == sLen && j == tLen;
        
        
    }
}


419. Battleships in a Board.txt

Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:
You receive a valid board, made of only battleships or empty slots.
Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.
At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.
Example:
X..X
...X
...X
In the above board there are 2 battleships.
Invalid Example:
...X
XXXX
...X
This is an invalid board that you will not receive - as battleships will always have a cell separating between them.
Follow up:
Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?

solution 1: dfs
public class Solution {
    /**
     * @param board: the given 2D board
     * @return: the number of battle ships
     */
    public int countBattleships(char[][] board) {
        // Write your code here
        if(board == null || board.length ==0){
            return 0;
        }
        
        int rows = board.length;
        int cols = board[0].length;
        boolean visited[][] = new boolean[rows][cols];
        int count=0;
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols ; col++){
                char c= board[row][col];
                if(c == 'X' && !visited[row][col]){
                    count++;
                    dfs(board,row,col,rows, cols,visited);
                }
            }
        }
        
        return count;
        
    }
    
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    
    public void dfs(char[][] board, int row, int col, int rows, int cols, boolean visited[][]){
        if(row <0 || row >= rows || col < 0 || col >=cols || visited[row][col] || board[row][col] == '.'){
            return;
        }
        
        
        visited[row][col] = true;
        for(int dir[]: dirs){
            dfs(board,row+dir[0], col+dir[1], rows, cols, visited);
        }
        
        
    }
}

solution 2: 
class Solution {
    public int countBattleships(char[][] board) {
        int res= 0;
        
        if(board == null || board.length == 0){
            return res;
        }
        
        int rows = board.length;
        int cols = board[0].length;
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                if(board[row][col] != 'X') continue;
                if(row > 0 && board[row-1][col] == 'X'){
                    continue;
                }else if(col > 0 && board[row][col-1] == 'X'){
                    continue;
                }
                
                
                res++;
                
            }
        }
        
        return res;        
    }
}

438. Find All Anagrams in a String.txt

Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.

The order of output does not matter.

Example 1:

Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

solution: sliding window

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        if(s.length() < p.length()) return res;
        
        Map<Character,Integer> map = new HashMap<>();
        for(char c: p.toCharArray()){
            map.put(c, map.getOrDefault(c,0)+1);
        }
        
        int l = 0, r = 0, counter = map.size();
        
        while(r < s.length()){
            char cRight = s.charAt(r);
            if(map.containsKey(cRight)){
                map.put(cRight, map.get(cRight) -1);
                if(map.get(cRight) == 0){
                    counter--;
                }
            }
            r++;
            
            while(counter == 0){
                char cLeft = s.charAt(l);
                if(map.containsKey(cLeft)){
                    map.put(cLeft, map.get(cLeft)+1);
                    if(map.get(cLeft) > 0){
                        counter++;
                    }
                }
                
                if(r - l == p.length()){
                    res.add(l);
                }
                l++;
                
            }
            
        }
        return res;
        
    }
}


443. String Compression.txt

Given an array of characters, compress it in-place.

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a character (not int) of length 1.

After you are done modifying the input array in-place, return the new length of the array.


Follow up:
Could you solve it using only O(1) extra space?


Example 1:
Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
Example 2:
Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.
Example 3:
Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
Note:
All characters have an ASCII value in [35, 126].
1 <= len(chars) <= 1000.

public class Solution {
    /**
     * @param str: a string
     * @return: a compressed string
     */
    public String compress(String str) {
        // write your code here
        if(str == null || str.length() <2) return str;
        
        StringBuilder sb = new StringBuilder();
        
        char prev = str.charAt(0);
        int count = 1;
        for(int i = 1; i < str.length();i++){
            char curr = str.charAt(i);
            if(curr == prev){
                count++;
            }else{
                sb.append(prev).append(count);
                prev = curr;
                count=1;
            }
            
            if(i == str.length()-1){
                sb.append(prev).append(count);
            }
        }
        
        return sb.length()>=str.length()?str:sb.toString();
    }
}


445. Add Two Numbers II.txt

You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null && l2 == null) return null;
        if(l1 !=null && l2 != null){
            Stack<ListNode> s1 = new Stack<>();
            Stack<ListNode> s2 = new Stack<>();
            
            while(l1 != null){
                s1.push(l1);
                l1 = l1.next;
            }
            
            while(l2 != null){
                s2.push(l2);
                l2 = l2.next;
            }
            int carry = 0;
            ListNode head = null;
            while(!s1.isEmpty() || !s2.isEmpty()){
                int v1 = s1.isEmpty()?0: s1.pop().val;
                int v2 = s2.isEmpty()?0: s2.pop().val;
                int currVal = (v1 + v2 + carry)%10;
                carry = (v1 + v2 + carry)/10;
                ListNode list = new ListNode(currVal);
                list.next = head;
                head= list;
            }
            
            if(carry > 0){
                ListNode list = new ListNode(carry);
                list.next = head;
                head= list;
            }
            
            return head;
            
        }else{
            return l1 == null? l2: l1;
        }
        
    }    
}


449. Serialize and Deserialize BST.txt

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.

The encoded string should be as compact as possible.

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    private final static char SP=',';
    private final static char EMPTY='#';
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb= new StringBuilder();
        if(root == null) return "";
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode curr = stack.pop();
            if(curr == null){
                sb.append(EMPTY);
            }else{
                sb.append(curr.val);

                stack.push(curr.right);
                stack.push(curr.left);
            }
            
            sb.append(SP);
        }
        
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data == null || data.length() == 0) return null;
        String array[] = data.split("\\" + SP);
        Queue<String> queue = new LinkedList<>();
        for(String val: array){
            queue.add(val);
        }
        
        return deserializeHelper(queue);
    }
    
    public TreeNode deserializeHelper(Queue<String> queue){
        if(queue.isEmpty()) return null;
        String valStr = queue.remove();
        if(valStr.equals("" + EMPTY)) return null;
        int val = Integer.valueOf(valStr);
        TreeNode root = new TreeNode(val);
        root.left = deserializeHelper(queue);
        root.right = deserializeHelper(queue);
        
        return root;
        
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));


452. Minimum Number of Arrows to Burst Balloons.txt

There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.

Example:

Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (b

class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points == null || points.length == 0) return 0;
        
        Arrays.sort(points, (int[] p1, int[] p2) ->{
            if(p1[0] != p2[0]){
                    return p1[0] - p2[0];                    
            }
            return p1[1] - p2[1];
        });
        
        int[] prev = points[0];
        int len = points.length;
        int res = 1;
        for(int row = 1; row < len; row++){
            int[] curr = points[row];
            if(curr[0] > prev[1]){
                res++;
                prev = curr;
            }else{
                prev[1] = Math.min(curr[1], prev[1]);
            }
        }
        
        return res;
    }
}


463. Island Perimeter.txt

You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

Example:

[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:

class Solution {
    int dirs[][] = {{-1,0},{1,0},{0,-1},{0,1}};
    public int islandPerimeter(int[][] grid) {
        if(grid == null || grid.length == 0) return 0;
        
        int rows = grid.length;
        int cols = grid[0].length;
        int res = 0;
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                res += getEdgeCount(grid, row, col); 
            }
        }
        
        return res;
    }
    
    public int getEdgeCount(int[][] grid, int row, int col){
        if(grid[row][col] == 0) return 0;
        int count = 4;
        
        for(int dir[]: dirs){
            int newRow = row+ dir[0];
            int newCol = col + dir[1];
            if(newRow>=0 && newRow< grid.length && newCol >=0 && newCol < grid[0].length){
                if(grid[newRow][newCol] == 1){
                    count--;
                }
            }
        }
        
        return count;
    }
}


490. The Maze.txt

There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.

Example 1

Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: true
Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.

Example 2

Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: false
Explanation: There is no way for the ball to stop at the destination.

Note:
There is only one ball and one destination in the maze.
Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.


class Solution {
    
    final static int rowDirection[] = {-1,0,1,0};
    final static int colDirection[] =  {0,-1,0,1};
    
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        if(maze == null || maze.length == 0 || maze[0].length == 0){
            return false;
        }
        LinkedList<int[]> queue = new LinkedList<>();
        queue.add(start);
        boolean visited[][] = new boolean[maze.length][maze[0].length];
        visited[start[0]][start[1]] = true;
            while(!queue.isEmpty()){
            int[] pos = queue.remove();
            
            if(pos[0] == destination[0] && pos[1] == destination[1]){
                return true;
            }
            
            for(int i = 0; i < 4; i++){
               int currRow = pos[0]+ rowDirection[i];
               int currCol = pos[1] + colDirection[i];
                while(currRow >=0 && currRow <maze.length && currCol >= 0 && currCol < maze[0].length && maze[currRow][currCol] == 0){
                   currRow +=  rowDirection[i];
                    currCol +=  colDirection[i];     
                }
                
                    
                  if(!visited[currRow-rowDirection[i]][currCol-colDirection[i]]){
                    queue.add(new int[]{currRow-rowDirection[i],currCol-colDirection[i]});
                    visited[currRow-rowDirection[i]][currCol-colDirection[i]] = true;
                   }
            
                    
            }
            
             
        }
        
        return false;
        
        
    }
}


505. The Maze II.txt

There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.

Example 1

Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: 12
Explanation: One shortest way is : left -> down -> left -> down -> right -> down -> right.
             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.

Example 2

Input 1: a maze represented by a 2D array

0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0

Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: -1
Explanation: There is no way for the ball to stop at the destination.

Note:
There is only one ball and one destination in the maze.
Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.
Difficulty:
Total Accepted:8791
Total Submissions:22752
 Frequency: 11%
 Companies (leaked):


class Solution {
    
    final static int rowDirection[] = {-1,0,1,0};
    final static int colDirection[] =  {0,-1,0,1};
    
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        if(maze == null || maze.length == 0 || maze[0].length == 0){
            return -1;
        }
        LinkedList<int[]> queue = new LinkedList<>();
        int distances[][] = new int[maze.length][maze[0].length];

        
        for (int[] row: distances)
            Arrays.fill(row, Integer.MAX_VALUE);
        
        queue.add(start);
        distances[start[0]][start[1]] = 0 ;
        while(!queue.isEmpty()){
            int[] pos = queue.remove();

            for(int i = 0; i < 4; i++){
               int currRow = pos[0]+ rowDirection[i];
               int currCol = pos[1] + colDirection[i];
               int count = 0; 
                while(currRow >=0 && currRow <maze.length && currCol >= 0 && currCol < maze[0].length && maze[currRow][currCol] == 0){
                   currRow +=  rowDirection[i];
                    currCol +=  colDirection[i];     
                    count++;
                }

                if(distances[pos[0]][pos[1]] + count < distances[currRow-rowDirection[i]][currCol-colDirection[i]]) {
                    distances[currRow-rowDirection[i]][currCol-colDirection[i]] = distances[pos[0]][pos[1]] + count;
                    queue.add(new int[]{currRow-rowDirection[i],currCol-colDirection[i]});
                }
            }
        }
        
        return distances[destination[0]][destination[1]] == Integer.MAX_VALUE? -1: distances[destination[0]][destination[1]];
   }
}
                           


513. Find Bottom Left Tree Value.txt

Given a binary tree, find the leftmost value in the last row of the tree.

Example 1:
Input:

    2
   / \
  1   3

Output:
1
Example 2: 
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
Note: You may assume the tree (i.e., the given root node) is not NULL.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int res = root.val;
        
        while(!queue.isEmpty()){
            int size = queue.size();
            
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.remove();
                if(i == 0){
                    res = curr.val;
                }
                
                if(curr.left != null) queue.add(curr.left);
                if(curr.right != null) queue.add(curr.right);
            }
        }
        return res;
        
        
    }
}


535. Encode and Decode TinyURL.txt

Note: This is a companion problem to the System Design problem: Design TinyURL.
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.

Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

public class Codec {

    Map<String,String> urlMap = new HashMap<>();
    List<Character> charList = new ArrayList<>();
    private final static int SIZE = 6;
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        addToList('a','z');
        addToList('0','9');
        addToList('A','Z');
        
        String res = "";
        do{
            res = getRandom();
        }
        while(urlMap.containsKey(res));
        urlMap.put(res, longUrl);
        return res;
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        return urlMap.get(shortUrl);
    }
    
    private String getRandom(){
        StringBuffer sb = new StringBuffer(); 
        Random random = new Random();
        while(sb.length() < SIZE){
            int randomPos = random.nextInt(charList.size());
            sb.append(charList.get(randomPos));
        }
        
        return sb.toString();
    }
    
    private void addToList(char start, char end){
        for(char c=start; c<=end; c++){
            charList.add(c);
        }
        
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));


567. Permutation in String.txt

Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.
Example 1:
Input:s1 = "ab" s2 = "eidbaooo"
Output:True
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:
Input:s1= "ab" s2 = "eidboaoo"
Output: False
Note:
The input strings only contain lower case letters.
The length of both given strings is in range [1, 10,000].

solution 1: sliding window
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if(s1 == null || s1.length() == 0) return true;
        if(s2 == null || s2.length() == 0 || s1.length() > s2.length()) return false;
        
        Map<Character,Integer> map = new HashMap<>();
        int count = 0;
        for(char c: s1.toCharArray()){
            map.put(c, map.getOrDefault(c,0)+1);
        }
        count = map.size();
        char chars[] = s2.toCharArray();
        int l = 0, r = 0;
        while(r < s2.length()){

            char cr = chars[r];
            if(map.containsKey(cr)){
                map.put(cr, map.get(cr)-1);
                if(map.get(cr) == 0){
                    count--;
                }
            }
            r++;
            
            while(count == 0){
                char cl = chars[l];
                
                if(map.containsKey(cl)){
                    map.put(cl, map.get(cl)+1);
                    if(map.get(cl) > 0){
                        count++;
                    }
                }
                
                if(r-l == s1.length()){
                    return true;
                }
                l++;
            }
        }
        
        return false;
    }
}

solution 2: hash map
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        
        if(len1 > len2){
            return false;
        }
        
        Map<Character, Integer> map1 = new HashMap<>();
        Map<Character, Integer> map2 = new HashMap<>();
        
        for(char c: s1.toCharArray()){
            map1.put(c, map1.getOrDefault(c, 0) + 1);
        }
        
        for(int i = 0; i < len2; i++){
            if(i - len1 >= 0){
                int newCount = map2.get(s2.charAt(i- len1)) - 1;
                if(newCount == 0){
                    map2.remove(s2.charAt(i-len1));
                }else{
                    map2.put(s2.charAt(i-len1), newCount);
                }
            }
            
            map2.put(s2.charAt(i), map2.getOrDefault(s2.charAt(i),0) +1);
            if(map2.equals(map1)){
                return true;
            }
        }
        
        return false;
    }
}


572. Subtree of Another Tree.txt

572. Subtree of Another Tree
Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.

Example 1:
Given tree s:

     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4 
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.
Example 2:
Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.



/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 Solution 1: queues
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        Queue<TreeNode> queue  = new LinkedList<>();
        queue.add(s);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.remove();
                if(isSameTree(curr, t)){
                    return true;
                }
                
                if(curr.left != null){
                    queue.add(curr.left);
                }
                
                if(curr.right !=null){
                    queue.add(curr.right);
                }
            }
        }
        
        return false;
    }
    
    private boolean isSameTree(TreeNode curr, TreeNode t){
        if(curr == null){
            return false;
        }
        
        Queue<TreeNode> q1 = new LinkedList<>();
        Queue<TreeNode> q2 = new LinkedList<>();
        q1.add(curr);
        q2.add(t);
        
        while(!q1.isEmpty() && !q2.isEmpty()){
            TreeNode n1 = q1.remove();
            TreeNode n2 = q2.remove();
            
            if(n1 == null && n2== null){
                continue;
            }else if (n1 !=null && n2!=null){
                if(n1.val != n2.val){
                    return false;
                }
                
                q1.add(n1.left);
                q1.add(n1.right);
                q2.add(n2.left);
                q2.add(n2.right);
            }else{
                return false;
            }
        }
        
        return q1.isEmpty() && q2.isEmpty();
        

    }
}


solution 2: iteration
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        Queue<TreeNode> queue  = new LinkedList<>();
        queue.add(s);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode curr = queue.remove();
                if(isSameTree(curr, t)){
                    return true;
                }
                
                if(curr.left != null){
                    queue.add(curr.left);
                }
                
                if(curr.right !=null){
                    queue.add(curr.right);
                }
            }
        }
        
        return false;
    }
    
    private boolean isSameTree(TreeNode curr, TreeNode t){
        if(curr == null && t == null){
            return true;
        }else if(curr != null & t!= null){
            if(curr.val != t.val){
                return false;
            }else{
                return isSameTree(curr.left, t.left) && isSameTree(curr.right, t.right);
            }
            
        }else{
            return false;
        }
        
       
        

    }
}


591. Tag Validator.txt

Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:

The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
A closed tag (not necessarily valid) has exactly the following format : <TAG_NAME>TAG_CONTENT</TAG_NAME>. Among them, <TAG_NAME> is the start tag, and </TAG_NAME> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.
A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched <, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.
A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
A < is unmatched if you cannot find a subsequent >. And when you find a < or </, all the subsequent characters until the next > should be parsed as TAG_NAME (not necessarily valid).
The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.
CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.
Valid Code Examples:
Input: "<DIV>This is the first line <![CDATA[<div>]]></DIV>"

Output: True

Explanation: 

The code is wrapped in a closed tag : <DIV> and </DIV>. 

The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. 

Although CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.

So TAG_CONTENT is valid, and then the code is valid. Thus return true.


Input: "<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>"

Output: True

Explanation:

We first separate the code into : start_tag|tag_content|end_tag.

start_tag -> "<DIV>"

end_tag -> "</DIV>"

tag_content could also be separated into : text1|cdata|text2.

text1 -> ">>  ![cdata[]] "

cdata -> "<![CDATA[<div>]>]]>", where the CDATA_CONTENT is "<div>]>"

text2 -> "]]>>]"


The reason why start_tag is NOT "<DIV>>>" is because of the rule 6.
The reason why cdata is NOT "<![CDATA[<div>]>]]>]]>" is because of the rule 7.
Invalid Code Examples:
Input: "<A>  <B> </A>   </B>"
Output: False
Explanation: Unbalanced. If "<A>" is closed, then "<B>" must be unmatched, and vice versa.

Input: "<DIV>  div tag is not closed  <DIV>"
Output: False

Input: "<DIV>  unmatched <  </DIV>"
Output: False

Input: "<DIV> closed tags with invalid tag name  <b>123</b> </DIV>"
Output: False

Input: "<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>"
Output: False

Input: "<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>"
Output: False
Note:
For simplicity, you could assume the input code (including the any characters mentioned above) only contain letters, digits, '<','>','/','!','[',']' and ' '.

class Solution {
    public boolean isValid(String code) {
        if(code == null || code.length() == 0) return false;
        if(code.charAt(0) != '<') return false;
        
        Stack<String> stack = new Stack<>();
        int i = 0, len = code.length();
        
        while(i < len){
            if(i > 0 && stack.isEmpty()) return false;
            if(code.startsWith("<![CDATA[", i)){
                int end = code.indexOf("]]>", i+9);
                if(end == -1) return false;
                i = end + 3;
            }else if(code.startsWith("</", i)){
                int end = code.indexOf(">", i+2);
                if(end == -1 || end == i+2 || (end - i - 2)> 9) return false;
                String s = code.substring(i+2, end);
                for(char c: s.toCharArray()){
                    if(!Character.isUpperCase(c)) return false;
                }           
                if(stack.isEmpty() || !stack.pop().equals(s)) return false;
                i = end +1;
            }else if(code.startsWith("<", i)){
                int end = code.indexOf(">", i);
                if(end == -1 || end == i+1 || (end - i -1 ) > 9) return false;
                String s = code.substring(i+1, end);
                for(char c: s.toCharArray()){
                    if(!Character.isUpperCase(c)) return false;
                }  
                stack.push(s);
                i = end +1;
            }else{
                i++;
            }
        }
        
        return stack.isEmpty();
        
    }
}


650. 2 Keys Keyboard.txt

Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:

Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.

Example 1:
Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
Note:
The n will be in the range [1, 1000].

solution 1: dp, time complexity O(n)
class Solution {
    public int minSteps(int n) {
        
        if(n == 0 || n == 1) return 0;
        int dp[] = new int[n+1];
        dp[1] = 0;
        dp[2] = 2;// one copy, one past
        for(int i= 2; i < n+1;i++){
            dp[i] = i;
            for(int j = i -1; j>0;j --){
                if(i % j == 0){
                    dp[i] = Math.min(dp[i], dp[j] + i/j);                    
                }
            }
            
        }
        
        return dp[n];
        
    }
}

solution 2:
To get the DP solution, analyse the pattern first by generating first few solutions
1: 0
2: 2
3: 3
4: 4
5: 5
6: 5
7: 7
8: 6
9: 6
10: 7
11: 11
12: 7
13: 13
14: 9
15: 8

Now, check the solution.
Eg: n=6
To get 6, we need to copy 3 'A's two time. (2)
To get 3 'A's, copy the 1 'A' three times. (3)
So the answer for 6 is 5

Now, take n=9.
We need the lowest number just before 9 such that (9% number =0). So the lowest number is 3.
So 9%3=0. We need to copy 3 'A's three times to get 9. (3)
For getting 3 'A's, we need to copy 1 'A' three times. (3)
So the answer is 6

Finally to analyse the below code, take n=81.
To get 81 we check
if (81 % 2 ==0) No
if (81 % 3 ==0) Yes
So we need to copy 81/3 = 27 'A's three times (3)
Now to get 27 'A's, we need to copy 27/3= 9 'A's three times (3)
To get 9 'A's, we need to copy 9/3=3 'A's three times (3)
And to get 3 'A's, we need to copy 3/3=1 'A's three times (3)
Final answer is 3+3+3+3 = 12

Last Example, n=18
18/2 = 9 Copy 9 'A's 2 times (2)
9/3=3 Copy 3 'A's 3 times (3)
3/3=1 Copy 1'A's 3 times (3)
Answer: 2+3+3= 8

time complexity: O(N Square root)
class Solution {
    public int minSteps(int n) {
        
        if(n == 0 || n == 1) return 0;
        int res = 0;
        
        for(int i = 2; i < n+1 ; i++){
        	//need to use while as it need to keep on reducing, i.e 64 /2 /2 /2 /2 /2 /2 
            while(n%i == 0){
                res += i;
                n = n/i;
            }
        }
        
        return res;
    }
}

class Solution {
    public int minSteps(int n) {
        
        if(n == 0 || n == 1) return 0;
        int res = 0;
        int i = 2;
        
        while(n > 1){
            while(n%i == 0){
                res += i;
                n = n/i;
            }
            i++;
        }
        
        return res;
    }
}

651.4 Keys Keyboard.txt

Description
Imagine you have a special keyboard with the following keys:

Key 1: (A): Print one 'A' on screen.

Key 2: (Ctrl-A): Select the whole screen.

Key 3: (Ctrl-C): Copy selection to buffer.

Key 4: (Ctrl-V): Print buffer on screen appending it after what has already been printed.

Now, you can only press the keyboard for N times (with the above four keys), find out the maximum numbers of 'A' you can print on screen.

public class Solution {
    /**
     * @param N: an integer
     * @return: return an integer
     */
    public int maxA(int N) {
        // write your code here
        if(N < 5) return N;
        
        int dp[] = new int[N+1];
        
        for(int i = 0; i <=N; i++){
            dp[i] = i;
            for( int j = 0; j <=(i-3); j++){
                dp[i] = Math.max(dp[i], dp[j] *(i-j-1));
            }
            
        }
        
        return dp[N];
    }
}


652. Find Duplicate Subtrees.txt

Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with same node values.

Example 1:

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
The following are two duplicate subtrees:

      2
     /
    4
and

    4
Therefore, you need to return above trees' root in the form of a list.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        List<TreeNode> res = new ArrayList<>();
        if (root == null) return res;
        preorder(root, res, new HashMap<String, Integer>());
        return res;
    }

    private String preorder(TreeNode node, List<TreeNode> res, Map<String, Integer> map) {
        if (node == null) {
            return "#";
        }
        String serial = node.val + "," + preorder(node.left, res, map) + "," + preorder(node.right, res, map);
        System.out.println("" + serial);
        if (map.getOrDefault(serial, 0) == 1) {
            res.add(node);
        }
        map.put(serial, map.getOrDefault(serial, 0) + 1);

        return serial;
    }

}


653. Two Sum IV - Input is a BST.txt

653. Two Sum IV - Input is a BST
iven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.

Example 1:
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
Example 2:
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root == null || (root.left== null && root.right == null)){
            return false;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        stack.add(root);
        
        while(!stack.isEmpty()){
            TreeNode curr = stack.pop();
            if((curr.val != k - curr.val) && bst(root, (k- curr.val))){
                return true;
            }
            
            if(curr.left != null){
                stack.push(curr.left);
            }
            
            if(curr.right != null){
                stack.push(curr.right);
            }
        }
        
        return false;
        
    }
    
    public boolean bst(TreeNode root, int k){
        if(root == null){
            return false;
        }else{
            if(k > root.val){
                return bst(root.right, k);
            }else if(k < root.val){
                return bst(root.left,k);
            }else{
                return true;
            }
        }

    }
}

654. Maximum Binary Tree.txt

654. Maximum Binary Tree

Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:

The root is the maximum number in the array.
The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.
The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.
Construct the maximum tree by the given array and output the root node of this tree.

Example 1:
Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
Note:
The size of the given array will be in the range [1,1000].


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums == null || nums.length == 0){
            return null;
        }
        return helper(nums, 0, nums.length-1);   
    }
    
    private TreeNode helper(int[] nums, int start, int end){
        if(start > end){
            return null;
        }
        
        int nodeIndex = findIndexOfMax(nums, start, end);
        TreeNode node = new TreeNode(nums[nodeIndex]);
        node.left = helper(nums, start, nodeIndex -1);
        node.right = helper(nums, nodeIndex+1, end);
        
        return node;
    }
    
    private int findIndexOfMax(int[] nums, int start, int end){
        int index = start;
        int max = nums[start];
        for(int i = start+1; i <= end; i++){
            if(max < nums[i]){
                index = i;
                max = nums[i];
            }
        }
        
        return index;
        
    }
}

658. Find K Closest Elements.txt

Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.

Example 1:
Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]
Example 2:
Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]
Note:
The value k is positive and will always be smaller than the length of the sorted array.
Length of the given array is positive and will not exceed 104
Absolute value of elements in the array and x will not exceed 104
UPDATE (2017/9/19):
The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.

class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
       
        int start = 0, end = arr.length -k;
        while(start < end){
            int mid = start + (end - start)/2;
            if(x > arr[mid]){
                if(x - arr[mid] > arr[mid+k] - x){
                    start = mid + 1;
                }else{
                    end = mid;
                }
            }else{
                end = mid;
            }
        }
       
        for(int index = start; index < start + k ; index++){
            res.add(arr[index]);
        }
       
        return res;
        
    }
}


684. Redundant Connection.txt

In this problem, a tree is an undirected graph that is connected and has no cycles.

The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.

The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.

Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u < v.

Example 1:
Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3
Example 2:
Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]
Output: [1,4]
Explanation: The given undirected graph will be like this:
5 - 1 - 2
    |   |
    4 - 3
Note:
The size of the input 2D-array will be between 3 and 1000.
Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.

Update (2017-09-26):
We have overhauled the problem description + test cases and specified clearly the graph is an undirected graph. For the directed graph follow up please see Redundant Connection II). We apologize for any inconvenience caused.

class Solution {
     private class UnionFind{
        int parents[];

        public UnionFind(int n){
            parents = new int[n+1];
            for(int i = 0; i < n+1; i++){
                parents[i] = i;
            }
        }
        public int find(int x){
            if(parents[x] != x){
                parents[x] = find(parents[x]);
            }

            return parents[x];
        }

        public boolean union(int x, int y){
            int px = find(x);
            int py = find(y);

            if(px == py){
                return false;
            }

            parents[py] = px;

            return true;
        }

    }
    
    public int[] findRedundantConnection(int[][] edges) {
        int emptyArray[] = new int[2];
        if(edges == null || edges.length == 0){
            return emptyArray;
        }
        
        UnionFind ufs = new UnionFind(edges.length);
        for( int i = 0; i < edges.length; i++){
            if( ufs.union(edges[i][0], edges[i][1]) == false){
                return edges[i];
            }
        }
               
        return emptyArray;
    }
}


692. Top K Frequent Words.txt

Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

Example 1:
Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
Explanation: "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.
Example 2:
Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
Output: ["the", "is", "sunny", "day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Input words contain only lowercase letters.
Follow up:
Try to solve it in O(n log k) time and O(n) extra space.


class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        
         List<String> res = new ArrayList<>();
        if(words == null || words.length == 0){
            return res;
        }
        
        Map<String,Integer> wordMap = new HashMap<>();
        
        for(String word: words){
            wordMap.put(word,wordMap.getOrDefault(word,0)+1);
        }
        /**
        he solution is using min-heap, which keeps heap's size to K. With min-heap, the top K elements are
        actually at the bottom of the heap. Hence, at case where a.getValue() == b.getValue(), we want to 
        add "abd" before "abc" into the min-heap, so that when executing line result.add(0, pq.poll().getKey());,
        abc will go before abd in the result. Hope this help!
        **/
        Comparator<String> comparator = new Comparator<String>(){
            @Override
            public int compare(String wf1,String wf2){
                if(wordMap.get(wf1) == wordMap.get(wf2)){
                    return wf2.compareTo(wf1);
                }
                
                return wordMap.get(wf1) - wordMap.get(wf2);
            }
        };
        
        PriorityQueue<String> pq = new PriorityQueue<>(k,comparator);
        
        
        for(Map.Entry<String,Integer> entry: wordMap.entrySet()){
            pq.add(entry.getKey());
            if(pq.size() > k ){
                pq.remove();
            }

        }
       
        while(!pq.isEmpty()){
            res.add(pq.remove());
        }
        Collections.reverse(res);
        return res;
        
    }
                  
  
}


694. Number of Distinct Islands.txt

Problem:

 Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
 Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.

Example 1:

 11000 
   11000 
   00011 
   00011
 Given the above grid map, return 1.

Example 2:

 11011 
   10000 
   00001 
   11011
 Given the above grid map, return 3.
 Notice that: 
   1 1 
   1 
   and 
   1 
   1 1  
   are considered different island shapes, because we do not consider reflection / rotation.

Note:

 The length of each dimension in the given grid does not exceed 50.

class Solution {
    Set<String> shapes = new HashSet<>();
    public int numDistinctIslands(int[][] grid) {
        
        if(grid == null || grid.length == 0 || grid[0].length == 0){
            return 0;
        }
        
        int rows = grid.length;
        int cols = grid[0].length;
        
        for(int r = 0; r < rows; r++){
            for(int c = 0; c < cols; c++){
               StringBuilder sb = new StringBuilder();
               dfs(grid,r,c,rows,cols, 'o',sb); 
               if(sb.length() >0){
                shapes.add(sb.toString());
               }
            }
        }
        
        return shapes.size();
        
    }
    
    private void dfs(int[][] grid, int row, int col, int rows, int cols, char di, StringBuilder sb){
        if(row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] <= 0){
            return;
        }
        
        sb.append(di);
        grid[row][col] = -1;
        dfs(grid,row-1,col,rows,cols,'u', sb);
        dfs(grid,row+1,col,rows,cols,'d', sb);
        dfs(grid,row,col-1,rows,cols,'l',sb);
        dfs(grid,row,col+1,rows,cols,'r',sb);
        sb.append('b');

        
        
    }
}


702. Concatenated String with Uncommon Characters of Two Strings.txt

Description
Two strings are given and you have to modify 1st string such that all the common characters of the 2nd strings have to be removed and the uncommon characters of the 2nd string have to be concatenated with uncommon characters of the 1st string.

Have you met this question in a real interview?  
Example
Given s1 = aacdb, s2 = gafd
return cbgf

Given s1 = abcs, s2 = cxzca;
return bsxz

public class Solution {
    /**
     * @param s1: the 1st string
     * @param s2: the 2nd string
     * @return: uncommon characters of given strings
     */
    public String concatenetedString(String s1, String s2) {
        // write your code here
        StringBuilder res = new StringBuilder();
        
        Set<Character> set1 = new HashSet<>();
        Set<Character> set2 = new HashSet<>();
        
        for(char c: s2.toCharArray()){
            set2.add(c);
        }
        
        for(char c: s1.toCharArray()){
            set1.add(c);
        }
        
        for(char c: s1.toCharArray()){
            if(!set2.contains(c)){
                res.append(c);
            }
        }
        
        for(char c: s2.toCharArray()){
            if(!set1.contains(c)){
                res.append(c);
            }
        }
        
        return res.toString();
        
    }
}


722. Remove Comments.txt

Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code. This represents the result of splitting the original source code string by the newline character \n.

In C++, there are two types of comments, line comments, and block comments.

The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.

The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.

The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.

If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.

There will be no control characters, single quote, or double quote characters. For example, source = "string s = "/* Not a comment. */";" will not be a test case. (Also, nothing else such as defines or macros will interfere with the comments.)

It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.

Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.

After removing the comments from the source code, return the source code in the same format.

Example 1:
Input: 
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]

The line by line code is visualized as below:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}

Output: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]

The line by line code is visualized as below:
int main()
{ 
  
int a, b, c;
a = b + c;
}

Explanation: 
The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.
Example 2:
Input: 
source = ["a/*comment", "line", "more_comment*/b"]
Output: ["ab"]
Explanation: The original source string is "a/*comment\nline\nmore_comment*/b", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].
Note:

The length of source is in the range [1, 100].
The length of source[i] is in the range [0, 80].
Every open block comment is eventually closed.
There are no single-quote, double-quote, or control characters in the source code.


class Solution {
    public List<String> removeComments(String[] source) {
        List<String> res = new ArrayList<>();
        if(source == null || source.length == 0){
            return res;
        }
        
        boolean blocked = false;
        StringBuilder newLine = null;
        
        for(String line: source){
            int i = 0;
            int len = line.length();
            char chars[] = line.toCharArray();
            if(!blocked) newLine = new StringBuilder();
            
            while(i < len){
                if(!blocked &&  i + 1 < len &&  chars[i] == '/' && chars[i+1] == '*'){
                    blocked = true;
                    i++;
                }else if(blocked && i+1 < len && chars[i] == '*' && chars[i+1] == '/'){
                    blocked = false;
                    i++;
                }else if(!blocked & i+1 < len && chars[i] == '/' && chars[i+1] == '/'){
                    break;
                }else{
                    if(!blocked){
                        newLine.append(chars[i]);
                    }   
                }
                                
                i++;
            }
            
            if(!blocked && newLine.length() > 0){
                res.add(newLine.toString());
            }
            
        }
        
        return res;
        
    }
}

728. Three Distinct Factors - lintcode.txt

Description
Given a positive integer n (1 <= n <= 10^18). Check whether a number has exactly three distinct factors, return true if it has exactly three distinct factors, otherwise false.


public class Solution {
    /**
     * @param n: the given number
     * @return:  return true if it has exactly three distinct factors, otherwise false
     */
    public boolean isThreeDisctFactors(long n) {
        // write your code here
        if(n < 4) return false;
        
        long x = (long)Math.sqrt(n);
        
        return x*x == n && isPrime(x);
       
    }
    
    public boolean isPrime(long n){
        if(n == 1) return false;
        if(n == 2) return true;
        
        for(long i = 2; i <=Math.sqrt(n); i++){
            if(n % i == 0){
                return false;
            }
        }
        
        return true;        
    }
}


746. Min Cost Climbing Stairs.txt

On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.

Example 1:
Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.
Example 2:
Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
Note:
cost will have a length in the range [2, 1000].
Every cost[i] will be an integer in the range [0, 999].
solution 1: memorization
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        if(cost == null || cost.length < 2){
            return 0;
        }
        
        if(cost.length == 1){
            return 0;
        }
        
        if(cost.length == 2){
            return Math.min(cost[0], cost[1]);
        }
        
        //min cost to climb to i-th step
        int mem[] = new int[cost.length+1];
        mem[0] = 0;
        mem[1] = 0;
        
        for(int i = 2; i <= cost.length; i++){
            mem[i] = Math.min(mem[i-1] + cost[i-1], mem[i-2] + cost[i-2]);
        }
        
        
        return mem[cost.length];
        
        
    }
}

#2 solution 2 - dp
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        if(cost == null || cost.length < 3){
            return 0;
        }
        
        
       
        //min cost to clime to i-th step
        int p = 0, q = 0, r;
        
        
        for(int i = 2; i <= cost.length; i++){
            
            r = Math.min(p + cost[i-2], q + cost[i-1] );
            p = q;
            q = r;
        }
        
        
        return q;
        
        
    }
}


762. Prime Number of Set Bits in Binary Representation.txt

Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.

(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.)

Example 1:

Input: L = 6, R = 10
Output: 4
Explanation:
6 -> 110 (2 set bits, 2 is prime)
7 -> 111 (3 set bits, 3 is prime)
9 -> 1001 (2 set bits , 2 is prime)
10->1010 (2 set bits , 2 is prime)
Example 2:

Input: L = 10, R = 15
Output: 5
Explanation:
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)
Note:

L, R will be integers L <= R in the range [1, 10^6].
R - L will be at most 10000.

class Solution {
    public int countPrimeSetBits(int L, int R) {
        int count = 0;
        
        for(int i = L; i <=R; i++){
            int bits = getCountOfBit(i);
            if(isPrime(bits)){
                count++;
            }
        }
        return count;
    }
    
    public int getCountOfBit(int num){
        int count = 0;
        while(num > 0){
            if(num %2 == 1){
                count++;
            }
            num = num>>1;
        }
        
        
        return count;
    }
    
    public boolean isPrime(int num){
        if(num <= 1){
            return false;
        }

        for(int i = 2; i*i <= num;i++){
            if(num % i == 0){
               return false; 
            }
        }
        
        return true;
        
    }
}


763. Partition Labels.txt

A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.

Example 1:
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
Note:

S will have length in range [1, 500].
S will consist of lowercase letters ('a' to 'z') only.

class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> res = new ArrayList<>();
        if(S == null || S.length() == 0){
            return res;
        }
        
        int hash[] = new int[26];
        Arrays.fill(hash, -1);
        
        for(int i = S.length()-1; i >=0;i--){
            int index = S.charAt(i) - 'a'; 
            
            if(hash[index]< 0){
                hash[index] = i;
            }
        }
        
        int start = 0, end = Integer.MIN_VALUE;
        for(int i = 0;i < S.length(); i++){
            int index = S.charAt(i) - 'a'; 
            end = Math.max(end, hash[index]);
            
            if(end == i){
                res.add(end - start + 1);
                start = end +1;
                
            }
            
        }
        
        return res;
        
    }
}


771. Jewels and Stones.txt

771. Jewels and Stones
You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:

Input: J = "aA", S = "aAAbbbb"
Output: 3
Example 2:

Input: J = "z", S = "ZZ"
Output: 0
Note:

S and J will consist of letters and have length at most 50.
The characters in J are distinct.

class Solution {
    public int numJewelsInStones(String J, String S) {
        if(J == null || J.length() == 0 || S== null || S.length() == 0){
            return 0;    
        }
        
        int bucket[] = new int[128];
        int res = 0;
        for(char c: S.toCharArray()){
            bucket[c]++;
        }
        
        for(char c: J.toCharArray()){
            for(int i = 0 ;i < bucket[c];i++){
                res++;
            }
            
        }
        
        return res;
        
    }
}


775. Global and Local Inversions.txt

We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.

The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].

The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].

Return true if and only if the number of global inversions is equal to the number of local inversions.

Example 1:

Input: A = [1,0,2]
Output: true
Explanation: There is 1 global inversion, and 1 local inversion.
Example 2:

Input: A = [1,2,0]
Output: false
Explanation: There are 2 global inversions, and 1 local inversion.
Note:

A will be a permutation of [0, 1, ..., A.length - 1].
A will have length in range [1, 5000].
The time limit for this problem has been reduced.

Key insights:

every local inversion is also a global inversion
so “local inversions == global inversions” can be interpreted as “there are only local inversions”
if there are only local inversions, the array will be sorted after making all local inversions
if there are inversions that are not local, the array won’t be sorted after making all local inversions
remember to set i = i+2 after swap

class Solution {
    public boolean isIdealPermutation(int[] A) {
        if(A == null || A.length == 0){
            return true;
        }
        
        
        //cal local inversions
        for(int i = 0; i < A.length-1;){
            if(A[i] > A[i+1]){
                swap(A, i, i+1);
                i += 2;
            }else{
                i++;
            }
        }
        
        //cal gloable inversions
        for(int i = 0; i < A.length -1; i++){
            if(A[i] > A[i+1]){
                return false; 
            }
        }
        
        return true;
    }
    
    private void swap(int A[], int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
}


791. Custom Sort String.txt

S and T are strings composed of lowercase letters. In S, no letter occurs more than once.

S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.

Return any permutation of T (as a string) that satisfies this property.

Example :
Input: 
S = "cba"
T = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.
 

Note:

S has length at most 26, and no character is repeated in S.
T has length at most 200.
S and T consist of lowercase letters only.

class Solution {
    public String customSortString(String S, String T) {
        StringBuilder sb = new StringBuilder();
        if(S == null || S.length() < 2 || T == null || T.length() == 0){
            return S;
        }
        
        int bucket[] =new int[26];
        for(char c: T.toCharArray()){
            bucket[c-'a']++;
        }
        
        for(char c:S.toCharArray()){
            for(int i = 0; i < bucket[c-'a']; i++){
                sb.append(c);
            }
            bucket[c-'a'] = 0;
        }
        
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < bucket[i]; j++){
                if(bucket[i] !=0){
                    sb.append((char)('a' +i));
                }
            }
            bucket[i] = 0;
            
        }
        
        return sb.toString();
        
    }
}


794. Valid Tic-Tac-Toe State.txt

A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.

The board is a 3 x 3 array, and consists of characters " ", "X", and "O".  The " " character represents an empty square.

Here are the rules of Tic-Tac-Toe:

Players take turns placing characters into empty squares (" ").
The first player always places "X" characters, while the second player always places "O" characters.
"X" and "O" characters are always placed into empty squares, never filled ones.
The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
Example 1:
Input: board = ["O  ", "   ", "   "]
Output: false
Explanation: The first player always plays "X".

Example 2:
Input: board = ["XOX", " X ", "   "]
Output: false
Explanation: Players take turns making moves.

Example 3:
Input: board = ["XXX", "   ", "OOO"]
Output: false

Example 4:
Input: board = ["XOX", "O O", "XOX"]
Output: true
Note:

board is a length-3 array of strings, where each string board[i] has length 3.
Each board[i][j] is a character in the set {" ", "X", "O"}.

class Solution {
    int rowVals[];
    int colVals[];
    int digranal = 0, antiDigranal = 0;
    public boolean validTicTacToe(String[] board) {
        int rows = board.length;
        int cols = rows;
        rowVals = new int[rows];
        colVals = new int[cols];
        int xCount = 0, oCount = 0;
        boolean xWin=false, oWin=false;
        
        for(int row = 0; row < rows; row++){
            for(int col = 0; col < cols; col++){
                int val = convert(board[row].charAt(col));
                rowVals[row] += val;
                colVals[col] += val;
                if(row == col){
                    digranal +=  val;
                }
                
                if((rows - row - 1) == col ){
                   antiDigranal +=  val;
                }
                if(val ==1) xCount++;
                if(val == -1) oCount++;
            }
        }
        
        if(oCount > xCount) return false;
        if(xCount-oCount > 1) return false;
        
        xWin = checkWin(rows);
        oWin = checkWin(-rows);
        if(xWin && oWin){
             return false;
        }
        
        if(xWin) return xCount == oCount+1;
        
        if(oWin) return xCount == oCount;
        
        return true;            
    }
    
    public boolean checkWin(int target){
        System.out.println("");
        for(int row = 0; row < Math.abs(target); row++){
            if(rowVals[row] == target || colVals[row] == target){
                return true;
            }
        }
        if(digranal == target || antiDigranal == target){           
            return true;
        }   
        
        return false;
    }
    public int convert(char c){
        if(c == 'X'){
            return 1;
        }else if(c == 'O'){
            return -1;
        }else{
            return 0;
        }
    }
}


836. Rectangle Overlap.txt

A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.

Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.

Given two (axis-aligned) rectangles, return whether they overlap.

Example 1:

Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true
Example 2:

Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false
Notes:

Both rectangles rec1 and rec2 are lists of 4 integers.
All coordinates in rectangles will be between -10^9 and 10^9.

solution:
is one is either left, or right, up or above the other, then, it's not overlapped
class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if(rec2[0] >= rec1[2] || rec1[0] >= rec2[2]) return false;
        if(rec2[1] >= rec1[3] || rec1[1] >= rec2[3]) return false;
        return true;
    }
}


843. Digital Flip.txt

Description
Give you an array of 01. Find the minimum number of flipping steps so that the array meets the following rules:
The back of 1 can be either1 or 0, but0 must be followed by 0.

solution 1: dp[][]
public class Solution {
    /**
     * @param nums: the array
     * @return: the minimum times to flip digit
     */
    public int flipDigit(int[] nums) {
        // Write your code here
        if(nums == null || nums.length == 0) return 0;
        
        int len = nums.length;
        // dp[i][0] -> the minimum number flips needed for i ~ n when nums[i] == 0
        // dp[i][1] -> the minimum number flips needed for i ~ n when nums[i] == 1
        int dp[][] = new int[len+1][2];
        
        for(int i = len -1; i >=0; i--){
            
            if(nums[i] == 1){
                 // current 1, can be followed by 0 or 1
                dp[i][1] = Math.min(dp[i + 1][0], dp[i + 1][1]);
                
                // do the flip, change 1 to 0, followed by 0
                dp[i][0] = dp[i+1][0]+1;
            }else{
                 // do the flip, change 0 to 1, followed by 0 or 1
                dp[i][1] = Math.min(dp[i + 1][0], dp[i + 1][1])+1;
                // current 0, followed by 0
                dp[i][0] = dp[i+1][0];
                
            }
            
        }
        
        return Math.min(dp[0][0], dp[0][1]);
        
        
    }
}


QA.txt


https://www.jiuzhang.com/qa/328/
为什么一般单序列动态规划如果INIT一个长度为N + 1的数组时，DP[0] = 1而不是0？
Answer:
好问题。

对于坐标的DP问题，dp[i]的i一般表示的是第i个位置。
对于序列的DP问题，dp[i]的i一般表示的是前i个位置。

前i个位置的话，就有前0个位置，前1个位置。。。前N个位置。这样是N+1个信息需要存储。为什么要单独把“前0”个的信息表示出来呢？因为对于比如，字符串的问题，前0个字符代表的是空串，往往是比较容易作初始化，让其他的dp[x]都来依赖dp[0]而计算得出结果。如果没有dp[0]的话，计算就会麻烦很多，你可以尝试一下。


ThingsToRemember.txt

trick and importance:
#1 for left,right pointer, remember to left++ and right--
#2 speel check, focus on ; )  make sure no : in the end, checking missing return statement
#3 make sure check above #2 when writing everyline codes
#4 to calculate distance with sum, add map.put(0, -1) to make it easier
#5 the spell of length
#6 remember to consider the carray when adding to listnodes
#7 add ; to the comparator
#8 remember to initialize variable 
#9  when remove last element from list, used
list.remove(list.size()-1)
#10 quickselect: average time O(N) - n+n/2+n/4.., worst(O(N2)) if reversed
mistakes and importance:
#11  type has to be in Comparator<type> comparator = new Comparator<type>()
#12 for map and list, need to check has elements or not

#186 Reverse Words in a String II
forgot to shift left++ and right--
remember to handle the edge case(i.e in the end)


#325Maximum Size Subarray Sum Equals k
added map.put(0, -1) to make it easy to calculate distance(i - pos)
try to finish everything in one loop

#Compare Version Numbers
make sure fill the missing length with 0

#Longest Palindromic Substring
Forgot to right else case
if(s.charAt(left) == s.charAt(right)){}else{return;}

#238. Product of Array Except Self
  using    int leftSides = 1, int rightSides = 1;

#287. Find the Duplicate Number
remember to use count to check with the mid value; if count > mid, then move high to mid

# Add Two Numbers
forgot to add the carry
need to add () around the conditional operator ?:

#160. Intersection of Two Linked Lists
forgot to move the point when calculate the list len
forgot to handle the edge case

# Merge k Sorted Lists
for using priorityQueue:
  forgot the check the null node
for Divide and conquer using two way merge:
 code could more precise. using while(right >0)

#98. Validate Binary Search Tree
3 solutions, top to bottom valid, in order search with recursion and iteration
for the iteration solution, could use   curr = curr.right;
instead of below,
    if(curr.right != null){
        curr = curr.right;
    }else{
        curr = null;
    }
#101. Symmetric Tree
used recursion or iteration with two queues 

# 270. Closest Binary Search Tree Value
the diff should be assigned Double.MAX_VALUE  
the diff should be > instead of <
  if(diff > Math.abs(target - curr.val)){

#129. Sum Root to Leaf Numbers
check root by left and right node, check null of them
if(root.left == null && root.right == null){  

#654. Maximum Binary Tree
Forgot the create node will real number(shouldn't be the index it self)
 int nodeIndex = findIndexOfMax(nums, start, end);
 TreeNode node = new TreeNode(nodeIndex);

#653. Two Sum IV - Input is a BST
forgot to check k==root.val case
forgot to check (curr.val != k - curr.val)
forgot to check missing return statement
forgot to check root has no leafs case

#572. Subtree of Another Tree
added wrong nodes into the queue, should be n1, n2 instead of curr q1.add(curr.left);
using recursion seems easier

#102. Binary Tree Level Order Traversal
 if (levelCount == 0) should be check after if(levelCount> 0) check, instead of if/else case

# 314. Binary Tree Vertical Order Traversal
 make sure the min and max data assign is opposite
    private int min = Integer.MAX_VALUE;
    private int max = Integer.MIN_VALUE;

#Inorder Successor in BST
Didn't notice this is BST

#200. Number of Islands
didn't notice the grid are chars
char[][] grid
if(grid[row][col] == 1) is not going to work
with union find: the union function should be
parent[pu] = parent[pv];
the grid pos: should be cols*row+ col


#261. Graph Valid Tree
with dfs, 1st, create all the list within the map in advance
2nd: check the status in the end of dfs to make sure all the nodes are touched
with unionfind solution: union method, should be parents[pv] = pu instead of parents[v] = u;
need to check n -1 == edges.length

#210. Course Schedule II
should handle dependency is empty case
  if( prerequisites ==null || prerequisites.length == 0){
      for(int i= 0; i< numCourses;i++){
          res[i] = i;
      }
      return res;
  }

 return empty array should be:
if(!dfs(list, i, status, resList)){
                return new int[0];
} 

207. Course Schedule
use 3 status
int status[] = new int[numCourses];
used list<list<Integer>> to store the edge information

#269. Alien Dictionary
use topological and dfs
similar with course schedule

#39. Combination Sum
mistakes made.
#a. in the backtrack method, the position should start the same instead of i+1;
#b. when remove last element from list, used
list.remove(list.size()) which threw the null point exception
backtrack template:
step 1: in main method: invoked
backtrack(res, new ArrayList<Integer>(), candidates, 0, target);

step2: in implementation method, go through all the elements and add, backtrack , remove last elements
 for(int i = pos; i < candidates.length; i++){
    currList.add(candidates[i]);
    backtrack(res, currList, candidates, i, target - candidates[i]);
    currList.remove(currList.size()-1);
}

17. Letter Combinations of a Phone Number
mistake: should use char as the key of map
 map.put('2', Arrays.asList('a','b','c'));

 backtrack template:
step 1: in main method: invoked
backtrack(res, new StringBuilder(), digits, 0);

step2: in implementation method, go through  the elements and add, backtrack , remove last elements

loop the possible candidate
int index = digits.charAt(pos) - '0';
        
for(char c: keys[index].toCharArray()){
    sb.append(c);
    backtrack(res,sb,digits, pos+1);
    sb.deleteCharAt(sb.length()-1);
}

#215. Kth Largest Element in an Array
need quickselect to invoke the partition
within quickSelect, return quickselect instead of partition
in the partition, should always check left<=right on each steps!

while(left <= right){
    while(left <=right && nums[left]<= nums[pivot]) left++;
    while(left<=right && nums[right] > nums[pivot]) right--;
    if(left <= right){
        swap(nums,left, right);
    }
}


#127. Word Ladder
 use Set<String> wordSet = new HashSet<>(wordList);
 use bfs + 26 letters

#126 Word Ladder II
tricky:the used word can not directly removed from the dictionary. The used word is only removed when steps change.
Used to visisted and unvisited set to check and make sure the same word could be added mulitple times in the same level

used bfs to get the graph(reversed way) and dfs to get the list. check word==startword. added word first after the operation, remove it from the list;

used 26 letters to find the right candidates

252. Meeting Rooms
sort withstart, get max end and compare with the new start in the loop


70. Climbing Stairs
could be handled with recursion+memorization or dp, make sure int dp[] = new int[n+1]

#15. 3Sum
make sure to compare with nums[l] instead of l
make usr remove the duplicated index and sorted the array before operation

#277. Find the Celebrity
make sure first loop only  case about knows(res,i)

305. Number of Islands II
make sure create grid[][] first and don't confused with positions[][];
use union find and count should start from 0 instead of position length(opposite with number of island 1)

#  Sliding Window Maximum
use ArrayDequeue,handle 0 to k element first, check queue is not empty and remove the value less than or equals to itself;
make sure compare with the nums[index] instead of index itself ;
remove the item oout of windows by check i - window.peekFirst() >= window_size 

# Minimum Window Substring
using hash[256] and count to track the usage of each alphabet
compare with s.charAt(left) or s.charAt(right) instead of left and right;
keep on move to the right
the right move will stop on end+1,no need to calculate len using right - left + 1, right - left is the correct as right has already moved one step after.
 right++;
  while(count == 0){
      if((right - left ) < minLen ){
          minLen = right - left ;

189. Rotate Array
make sure handle k = k%nums.length; k= k<0?k+nums.length:k

449. Serialize and Deserialize BST
for serialize: using preorder, store null node as "#"
for deseriazation, using queue,if poped is not null, root = TN(v); root.left=buildTree(queue);..

146. LRU Cache
make sure keep both key and val in the Node class
addToFront method need 5 steps
make evict_if_applicable method


# Find Median from Data Stream
use max and min queue

#79. Word Search
used dfs and backtrack
passed the current index
make sure only one place to check and edge case

212. Word Search II
Used DFS + Trie solution
TrieNode has TrieNode[26] and word end at that level

208.Implement Trie (Prefix Tree)
created class TrieNode
has TrieNode root in the Trie class

791. Custom Sort String
Use bucket solution
(char)('a'+i) could be used to convert int to char

775. Global and Local Inversions
every local inversion is also a global inversion
so “local inversions == global inversions” can be interpreted as “there are only local inversions”
if there are only local inversions, the array will be sorted after making all local inversions
if there are inversions that are not local, the array won’t be sorted after making all local inversions
remember to set i = i+2 after swap

771. Jewels and Stones
make sure int bucket[] = new int[128];

763. Partition Labels
make sure max(max, hash[i]) to get the updated end;
check current i == end

762. Prime Number of Set Bits in Binary Representation
try to get the count of 1s in the binary;
1 is not prime and 2 is the primary, make sure handle that in the isPrime method
for(int i = 2; i*i <= num;i++){

746. Min Cost Climbing Stairs
//min cost to climb to i-th step
int mem[] = new int[cost.length+1];
or using dp: dp1, dp2

380. Insert Delete GetRandom O(1)
public boolean remove(int val) {
        // write your code here
        if(!posMap.containsKey(val)){
            return false;
        }
        
        Integer lastVal = list.get(list.size()-1);
        int posLast = posMap.get(lastVal);
        int posOfVal = posMap.get(val);
        
        if(posLast != posOfVal){
            posMap.put(lastVal, posOfVal);
            list.set(posOfVal,lastVal);
        }
        
        list.remove(list.size()-1);
        posMap.remove(val);
        return true;
        
    }

297. Serialize and Deserialize Binary Tree
Used preorder to serialize the tree
used queue to deserialize the tree

235. Lowest Common Ancestor of a Binary Search Tree
make sure return when root = p or q

236. Lowest Common Ancestor of a Binary Tree
TreeNode left = lowestCommonAncestor(root.left, p, q);
TreeNode right = lowestCommonAncestor(root.right, p, q);

if(left != null && right != null){
    return root;
}

234. Palindrome Linked List.txt
the stack should push data < len/2; skip value check on len/2 and odd len

92. Reverse Linked List II
find preM, mNode and nNode postion and keep on move mNode after nNode, and point mNode to preM.next, util mNode == nNode\

204. Count Primes
isPrime[]
其算法是，给出要筛数值的范围, 找出以内的素数. 先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个素数5筛，把5留下，把5的倍数剔除掉；不断重复下去。


119. Pascal's Triangle II.txt
append 1 on every look, update value from right to left;

for(int i = 0; i <= rowIndex; i++){
    res.add(1);

    for(int j = i - 1; j > 0; j--){
        res.set(j, res.get(j-1) + res.get(j));
    }
}

684. Redundant Connection
public boolean union(int x, int y){
            int px = find(x);
            int py = find(y);
            
            if(px == py){
                return false;
            }
            
            //very important
            parents[py] = px;
            
            return true;
        }

#hash code implementation example
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + age;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + Arrays.hashCode(value);
    return result;
}


他山之石.txt


本帖最后由 Cats881119 于 2017-2-5 06:48 编辑


经验；
    这次出去onsite了一圈,发现大多数题目还是dfs bfs dp, 二分，sliding window，还有一些实现题
    （包括 拓扑排序 双指针 位运算 实现数据结构LRU LFU，stack/queue，Trie,外排序, 甚至是数据结构的设计等） 其他题目没怎么碰到。
    其中dfs bfs dp的题目加起来超过了65%+的算法题

    本来想这次努力刷题，接下来这辈子都不用刷题了，自然 现实又让我碰个头破血流，只能祈求接下来3年不要再刷题。（可能也是奢望吧）

    如果需要再次刷题，可以看看下面重点题目，应该可以再短时间准备出能勉强去三流公司面试的做题水平。

    1.dfs
    比较简单直接, 循环加递归  +dfs“枝丫”（由递归产生）的终止条件（终止递归）
    当然 这个循环可以是for循环，
    如Combinations

    还可以是是树里面遍历各个children node
     如 Minimum Depth of Binary Tree

    终止条件可以再循环内 也可以在循环外（其实本质是一样，就是终止这一支的递归）

    另外现在市场上还出现了一种 需要多重排列组合来得到最终结果的(1个排列组合得到的"半结果"还要去和另外一个“半结果”去排列组合)，那么就是dfs里嵌套dfs

    dfs的时间复杂度是O(b^m) b是分支系数（有多少个child/邻居） m是树/图的最大深度


    2.bfs （经常需要和建立图一起使用）
    还是比较简单直接， 就是找到一个起点，然后入queue 然后再出queue的时候把他的孩子都放入queue
    如Binary Tree Level Order Traversal
    当然，如果是bfs树，那么他的邻居就是他的孩子，
    如果是bfs矩阵，那么它的邻居就是他周围的node
    如果是bfs 其他东西(类似) 类似word ladder1 那么你就要稍微写点业务逻辑来找邻居。

    某大公司之前还碰到一题是 a/b =2  c/d =4   e/f =6   b/d=5 等等一堆（当然 原题比这个要隐晦许多） 然后问你a/e是多少
    我之前往错误的方向想了半天，实际上是建立一个图 然后bfs看看是否有联通的路径

    当然想往难的考可以 比如word ladder2
     BFS + Dijkstra's algorithm  +找到距离后dfs找最短路径
     “
       返回从词A到词B的各种路径 BFS + Dijkstra's algorithm
       Dijkstra's algorithm 是用来求 在一个有向图里的两点 是否存在路径，如果有的话，最短路径是多少
       在这里的ladder就是路径和他们之间所需的距离， 如果没有路径 那么他们的距离就 Integer.MAX_VALUE
       如果有多个不同的路径的话，我们会动态更新最短路径并且存在ladder这个map里 eg:(AB,3)->(AB->2)

        对于不含负权(距离为负)的有向图，这是目前已知的最快的单源最短路径算法。

         1.首先建立图 Map<String,List<String>> map; 每个合法的String和他的邻居，邻居就是变位一个词后能 生成的合法新String
        2.同时建立一个map来存每2个词之间的min ladder
        //ladder表示2点（2个词）之间的最短距离，如果没有就是无限大的距离
         //在这里 他们表示当前是String和 beginWord的距离
       Map<String,Integer> ladder = new HashMap<String,Integer>();
      ”

     某个面试官对 bfs找到最短路径后我用dfs找actual path 非常不满意，说可以不用dfs ，在之前bfs时候就记录路径 然后直接可以在找到最短距离时候得到结果。我查了一下地里，的确有  “对于ladder II这种寻找path的题 如果求所有路径的是需要先bfs然后dfs，但是如果是只要一条最短路径，只需要一次bfs。具体来说在bfs的过程中，在把下一层节点i加入queue的时候，用一个map记录，key是下一层节点i的id, value是本层的节点id。这样到最后，就可以从结束点开始往前找parent，一直找到开头的点。因为加入queue的过程就是确定下一层点的parent的过程，所以每个点只进入queue一次，这个用set来保证。我说的这个只是针对输出一个最短path的解法，不过感觉现在确实好多面经是输出一条，个人感觉这样面试官更好看，输出那么多他也看不完~~”
当时只剩几分钟了 ，没想出来，跪。


    3. DP
    DP的本质是什么， 就是从一个局部的,确定的解，推导出 所有由这个确定的局部解可能发生的情况，然后再这些情况里找到 最大/最小/最xxx，然后进一步推导 更大的局部解，
    然后直到全局解。
    比方说最简单例子 一维dp fibonacci 就是由f1 f2...推导出fn , f1 f2就是初始的确定局部解

    然后矩阵dp[j] 确定局部解可能是 dp[0][0] 和其中一条或者 两条边 dp[0] dp[0][j]   甚至是对角线dp
    如PascalTriangle  ,paint house II

    当然 其中可能不是1 1对应这么简单，在推导的过程中需要采用一定的业务逻辑
    如RegularExpressionMatching

    最后有可能题目不是很直接， 连确定的局部解都比较难找，那么可以换一种思路。

    如 BurstBalloons
    “ dp的本质是什么 是从确定的子问题推到到全局
      那么这个pop气球的问题比较特殊 因为假设你第一次pop2(产生平行宇宙1)
      那么你接下来就变成 134 adjacent    如果你第一次pop3(产生平行宇宙2) 那就变成124 adjacent
      adjacnt的变化导致你在 你在平行宇宙1 2 里 哪怕都是第二次pop4 产生的结果也是不一样的 而且对未来的总结果有影响

      所以并不符合 dp 是从确定的子问题推到到全局

      所以 另一种经常的dp思路 是从最后一个开始推导
      因为最后一个被干爆的气球 数组里只剩他一个了 nums[-1]*nums*nums[n]  然后 nums[-1] = nums[n] = 1
      所以最后一个干爆气球是i 得到coin是完全确定的

     那么在最后一个干爆气球是i是确定的情况下, 倒数第二个干爆的气球是啥 会产生什么coin, 也是确定的
      这样 就能从后往前推导出整个 pop的顺序, 然后都试一下得到最大的
      符合了 dp的本质
”

4.二分
       比方说想各种 sorted rotated array  或者/\这样的array 的稍微练习下他们的具体实现。

教训：
1. 第一个面试，哪怕电面一定要是你不想去的公司。因为第一个面试搞砸的可能性很高
2. 不要去太忙的公司/组上班， 如果一个candidate 上班都能刷题，另外一个candidate 要加班 oncall release 等等 要等10点 11点才可以开始刷题，你说那个candidate 有优势？ 
3.  一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程， 特别是公司的bar 的高度并不是一直不变的。
4.肯定不会去的公司/组，只要去一个练兵就够了，人的精力是有限的， back on back onsite对后一场的发挥压制很大。


lintcode\077. Longest Common Subsequence.txt

Description
Given two strings, find the longest common subsequence (LCS).

Your code should return the length of LCS.



Have you met this question in a real interview?  
Clarification
What's the definition of Longest Common Subsequence?

https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
http://baike.baidu.com/view/2020307.htm
Example
For "ABCD" and "EDCA", the LCS is "A" (or "D", "C"), return 1.

For "ABCD" and "EACB", the LCS is "AC", return 2.

解题思路：这类问题是第一次接触，不知道怎么做。百度了一下，发现了递推公式：dp【i】【j】：代表第一个字符串的前i个字符和第二个字符串的前j个字符比较能得到
的最长的公共子序列。s【i】 == s【j】 ，dp【i】【j】 = dp【i - 1】【j - 1】 + 1； s【i】 ！= s【j】 ， 
dp【i】【j】 = Max (dp[i][j - 1], dp[i - 1][j]); 初始化：dp【i】【0】 = dp【0】【j】 = 0； （i >= 1 && i <= l1[第一个字符串的长度] 、
j >= 1 && j <= l2）

相等的话自然是取dp【i - 1】【j - 1】  + 1，因为dp【i- 1】【j】 ， dp【i】【j -1】的值一定会小于等于dp【i - 1】【j - 1】  + 1，
因为这里i - 1个字符肯定还得花一个字符来和j匹配，这样最优的情况就是dp【i- 2】【j - 1】  +  1，那么dp【i - 1】【j - 1】>= kdp【i- 2】【j - 1】,
因为两个匹配的子串的长度更长，这样相同的字串的长度才会更大。不相等的情况就更容易理解了。
可能会有空串。

public class Solution {
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    public int longestCommonSubsequence(String A, String B) {
        // write your code here
        if(A == null || A.length() == 0 || B == null || B.length() ==0) return 0;
        int ALen = A.length();
        int BLen = B.length();
        int dp[][] = new int[ALen+1][BLen+1];
        for(int row = 1; row <=ALen; row++ ){
            for(int col = 1 ; col <=BLen; col++){
                dp[row][col] = Math.max(dp[row-1][col], dp[row][col-1]);
                
                if(A.charAt(row-1) == B.charAt(col-1)){
                    dp[row][col] = dp[row-1][col-1] +1;
                }
                
            }
        }
        
        return dp[ALen][BLen];
    }
}


lintcode\1409. Matrix Finding Number.txt

Description
A matrix mat is given to find out all the numbers that appear in the row. If there are multiple, return the minimum number . If not, return -1.

The size of the matrix is n * m ,n * m <= 10^6.
Each number is a positive integer that is not more than 100000.
Have you met this question in a real interview?  
Example
Given mat = [[1,2,3],[3,4,1],[2,1,3]], return 1.

Explanation:
1 and 3 appear every line, while 1 is smaller than 3.
Given mat = [[1,2,3],[3,4,2],[2,1,8]], return 2.

Explanation:
2 appears in every row of the matrix.

public class Solution {
    /**
     * @param mat: The matrix
     * @return: The answer
     */
    public int findingNumber(int[][] mat) {
        // Write your code here
        
        if( mat == null || mat.length == 0 || mat[0].length == 0) return -1;
        Set<Integer> set = new HashSet<>();
        int rows = mat.length;
        int cols = mat[0].length;
        
        for(int val: mat[0]){
            set.add(val);  
        }
        
        for(int row = 1; row < rows; row++){
            List<Integer> itemsToRemove = new ArrayList<>();
            for(int curr: set){
                boolean found = false;
                for(int col = 0; col < cols; col++){
                    if(curr == mat[row][col]){
                        found = true;
                        break;
                    }
                }
                if(found == false){
                     itemsToRemove.add(curr);
                }
            }
            set.removeAll(itemsToRemove);
        }
        
        if(set.size() == 0){
            return -1;
        }else{
            int min = Integer.MAX_VALUE;
            for(int val: set){
                min = Math.min(min, val);
            }
            
            return min;
        }
        
    }
}


lintcode\1410. Matrix Water Injection.txt

Description
Given a two-dimensional matrix, the value of each grid represents the height of the terrain. The flow of water will only flow up, down, right and left, and it must flow from the high ground to the low ground. As the matrix is surrounded by water, it is now filled with water from (R,C) and asked if water can flow out of the matrix.

The input matrix size is n x n, n <= 200.
Ensure that each height is a positive integer.
Have you met this question in a real interview?  
Example
Given

mat =
[
    [10,18,13],
    [9,8,7],
    [1,2,3]
]
R = 1, C = 1, return "YES"。

Explanation:
(1,1) →(1,2)→Outflow.
Given

mat = 
[
    [10,18,13],
    [9,7,8],
    [1,11,3]
]
R = 1, C = 1, return "NO"。

Explanation:
Since (1,1) cannot flow to any other grid, it cannot flow out.

public class Solution {
    /**
     * @param matrix: the height matrix
     * @param R: the row of (R,C)
     * @param C: the columns of (R,C)
     * @return: Whether the water can flow outside
     */
     
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    private static String YES = "YES";
    private static String NO = "NO";
    
    public String waterInjection(int[][] matrix, int R, int C) {
        // Write your code here
        if(matrix == null || matrix.length == 0) return NO;
        int rows = matrix.length;
        int cols = matrix[0].length;
        boolean status[][] = new boolean[rows][cols];
        return dfs(matrix,R,C,status);
    }
    
    private String dfs(int[][] matrix, int row, int col, boolean status[][]){
        if(row == matrix.length -1 || row == 0 || col == 0 || col == matrix[0].length-1) return YES;
        if(status[row][col]) return NO;
        
        status[row][col] = true;
        
        for(int dir[]:dirs){
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if(newRow >= 0 && newRow < matrix.length && newCol >=0 && newCol < matrix[0].length && matrix[row][col] > matrix[newRow][newCol]){
                if(dfs(matrix,row+dir[0], col+dir[1], status).equals(YES)){
                    return YES;
                }
            }
        }
        
        return NO;
    }
}

public class Solution {
    /**
     * @param matrix: the height matrix
     * @param R: the row of (R,C)
     * @param C: the columns of (R,C)
     * @return: Whether the water can flow outside
     */
    class Point{
        int x;
        int y;
        public Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }     
    int dirs[][] = {{-1,0},{0,1},{1,0},{0,-1}};
    public String waterInjection(int[][] matrix, int R, int C) {
        // Write your code here
        if(matrix == null || matrix.length == 0){
            return "NO";
        }
        int rows = matrix.length;
        int cols = matrix[0].length; 
        int status[][] = new int[rows][cols];
        Stack<Point> stack = new Stack<>();
        stack.push(new Point(R,C));
        status[R][C] = 1;
        
        while(!stack.isEmpty()){
            Point p = stack.pop();
            if(p.x == 0 || p.x == (rows-1) || p.y == 0 || p.y == (cols-1)){
                return "YES";
            }
            
            for(int dir[]:dirs){
                int newRow = p.x + dir[0];
                int newCol = p.y + dir[1];
                
                if(newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols){
                    continue;
                }
                
                if(matrix[p.x][p.y] > matrix[newRow][newCol] && status[newRow][newCol] == 0){
                    stack.push(new Point(newRow, newCol));
                    status[newRow][newCol] = 1;
                }
            }
        }
        
        return "NO";
        
        
        
    }
}


lintcode\596.Minimum Subtree.txt

Description
Given a binary tree, find the subtree with minimum sum. Return the root of the subtree.

LintCode will print the subtree which root is your return node.
It's guaranteed that there is only one subtree with minimum sum and the given binary tree is not an empty tree.

Have you met this question in a real interview?  
Example
Given a binary tree:

     1
   /   \
 -5     2
 / \   /  \
0   2 -4  -5 
return the node 1.

/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */

public class Solution {
    /**
     * @param root: the root of binary tree
     * @return: the root of the minimum subtree
     */
    int min = Integer.MAX_VALUE;
    TreeNode res = null;
    public TreeNode findSubtree(TreeNode root) {
        // write your code here
        helper(root);
        return res;
    }
    
    private int helper(TreeNode root){
        if(root == null) return 0;
        
        int left = helper(root.left);
        int right = helper(root.right);
        
        int result = left + root.val + right;
        if(result < min){
            min = result;
            res = root;
        }
        return result;
        
    }
}


lintcode\728. Three Distinct Factors.txt

Description
Given a positive integer n (1 <= n <= 10^18). Check whether a number has exactly three distinct factors, return true if it has exactly three distinct factors, otherwise false.

Have you met this question in a real interview?  
Example
Given n = 9, return true
Number 9 has exactly three factors: 1, 3, 9, so return true.

Given n = 10, return false

public class Solution {
    /**
     * @param n: the given number
     * @return:  return true if it has exactly three distinct factors, otherwise false
     */
    public boolean isThreeDisctFactors(long n) {
        // write your code here
        
        if(n <=3){
            return false;
        }
        
        long x = (long)Math.sqrt(n);
        return x*x == n && isPrime(n/x);
    }
    
    
    public boolean isPrime(long n){
        if (n == 1 ){
            return false;
        }
        
        if( n ==2){
            return true;
        }
        
        for(long i = 2; i*i <= n; i++){
            if(n%i == 0){
                return false;
            }
        }
        
        return true;
        
    }
}